package com.liyang.droneplus;

import android.Manifest;
import android.app.Dialog;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.ImageFormat;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.Point;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.SurfaceTexture;
import android.graphics.Typeface;
import android.graphics.YuvImage;
import android.media.projection.MediaProjectionManager;
import android.os.Build;
import android.os.Environment;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Looper;
import android.os.Message;
import android.support.annotation.NonNull;
import android.support.v4.app.ActivityCompat;
import android.support.v7.app.AlertDialog;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.util.Log;
import android.util.Size;
import android.util.TypedValue;
import android.view.Display;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.Surface;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.view.TextureView;
import android.view.View;
import android.view.ViewGroup;
import android.view.Window;
import android.view.WindowManager;
import android.widget.Button;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.RelativeLayout;
import android.widget.SlidingDrawer;
import android.widget.TextView;
import android.widget.Toast;

import com.amap.api.maps.AMap;
import com.amap.api.maps.AMapUtils;
import com.amap.api.maps.CameraUpdateFactory;
import com.amap.api.maps.CoordinateConverter;
import com.amap.api.maps.MapView;
import com.amap.api.maps.UiSettings;
import com.amap.api.maps.model.BitmapDescriptorFactory;
import com.amap.api.maps.model.CameraPosition;
import com.amap.api.maps.model.LatLng;
import com.amap.api.maps.model.Marker;
import com.amap.api.maps.model.MarkerOptions;
import com.amap.api.maps.model.Polyline;
import com.amap.api.maps.model.PolylineOptions;
import com.liyang.droneplus.adpater.RecognitionResultAdapter;
import com.liyang.droneplus.application.DemoApplication;
import com.liyang.droneplus.apriltags.ApriltagPoseEstimation;
import com.liyang.droneplus.apriltags.ApriltagR;
import com.liyang.droneplus.bean.RecognitionResultItem;
import com.liyang.droneplus.classifier.ApriltagsDetectAPIModel;
import com.liyang.droneplus.classifier.ReadConfigFileUtil;
import com.liyang.droneplus.classifier.Recognizer;
import com.liyang.droneplus.classifier.RecognizerForAprilTags;
import com.liyang.droneplus.classifier.TarmacDetectAPIModel;
import com.liyang.droneplus.media.DJIVideoStreamDecoder;
import com.liyang.droneplus.media.NativeHelper;
import com.liyang.droneplus.util.BorderedText;
import com.liyang.droneplus.util.ImageUtils;
import com.liyang.droneplus.util.LogUtil;
import com.liyang.droneplus.util.Logger;
import com.liyang.droneplus.util.PIDControlIncTest;
import com.liyang.droneplus.util.WriteFileUtil;
import com.liyang.droneplus.view.OverlayView;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.math.BigDecimal;
import java.nio.ByteBuffer;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.ScheduledExecutorService;

import dji.common.battery.BatteryState;
import dji.common.camera.SettingsDefinitions;
import dji.common.camera.SystemState;
import dji.common.error.DJIError;
import dji.common.flightcontroller.FlightControllerState;
import dji.common.flightcontroller.FlightMode;
import dji.common.flightcontroller.LEDsSettings;
import dji.common.flightcontroller.simulator.SimulatorState;
import dji.common.flightcontroller.virtualstick.FlightControlData;
import dji.common.flightcontroller.virtualstick.FlightCoordinateSystem;
import dji.common.flightcontroller.virtualstick.RollPitchControlMode;
import dji.common.flightcontroller.virtualstick.VerticalControlMode;
import dji.common.flightcontroller.virtualstick.YawControlMode;
import dji.common.gimbal.GimbalState;
import dji.common.mission.waypoint.WaypointMission;
import dji.common.mission.waypoint.WaypointMissionHeadingMode;
import dji.common.product.Model;
import dji.common.useraccount.UserAccountState;
import dji.common.util.CommonCallbacks;
import dji.internal.logics.CommonUtil;
import dji.sdk.base.BaseProduct;
import dji.sdk.battery.Battery;
import dji.sdk.camera.Camera;
import dji.sdk.camera.VideoFeeder;
import dji.sdk.codec.DJICodecManager;
import dji.sdk.flightcontroller.Compass;
import dji.sdk.flightcontroller.FlightController;
import dji.sdk.gimbal.Gimbal;
import dji.sdk.mission.MissionControl;
import dji.sdk.mission.timeline.TimelineElement;
import dji.sdk.mission.timeline.TimelineEvent;
import dji.sdk.mission.waypoint.WaypointMissionOperator;
import dji.sdk.products.Aircraft;
import dji.sdk.sdkmanager.DJISDKManager;
import dji.sdk.useraccount.UserAccountManager;
import dji.thirdparty.afinal.core.AsyncTask;
import dji.ux.panel.CameraSettingAdvancedPanel;
import dji.ux.panel.CameraSettingExposurePanel;
import dji.ux.panel.PreFlightCheckListPanel;
import dji.ux.widget.AutoExposureLockWidget;
import dji.ux.widget.BatteryWidget;
import dji.ux.widget.ConnectionWidget;
import dji.ux.widget.FlightModeWidget;
import dji.ux.widget.FocusExposureSwitchWidget;
import dji.ux.widget.FocusModeWidget;
import dji.ux.widget.GPSSignalWidget;
import dji.ux.widget.ManualFocusWidget;
import dji.ux.widget.PreFlightStatusWidget;
import dji.ux.widget.RemainingFlightTimeWidget;
import dji.ux.widget.RemoteControlSignalWidget;
import dji.ux.widget.ReturnHomeWidget;
import dji.ux.widget.TakeOffWidget;
import dji.ux.widget.VideoSignalWidget;
import dji.ux.widget.VisionWidget;
import dji.ux.widget.WiFiSignalWidget;
import dji.ux.widget.config.CameraConfigApertureWidget;
import dji.ux.widget.config.CameraConfigEVWidget;
import dji.ux.widget.config.CameraConfigISOAndEIWidget;
import dji.ux.widget.config.CameraConfigShutterWidget;
import dji.ux.widget.config.CameraConfigStorageWidget;
import dji.ux.widget.config.CameraConfigWBWidget;
import dji.ux.widget.controls.CameraControlsWidget;
import dji.ux.widget.dashboard.DashboardWidget;
import dji.ux.workflow.CompassCalibratingWorkFlow;

public class MainActivity extends AppCompatActivity implements DJICodecManager.YuvDataCallback, View.OnTouchListener, View.OnClickListener {

    private static final String TAG = MainActivity.class.getSimpleName();

    private enum DemoType {USE_SURFACE_VIEW_DEMO_DECODER}

    private static DemoType demoType = DemoType.USE_SURFACE_VIEW_DEMO_DECODER;

    private SurfaceView videostreamPreviewSf;
    private SurfaceHolder videostreamPreviewSh;
    private SurfaceHolder.Callback surfaceCallback;

    private VideoFeeder.VideoFeed standardVideoFeeder;
    protected VideoFeeder.VideoDataListener mReceivedVideoDataListener = null;

    private Camera mCamera;
    private DJICodecManager mCodecManager;      // Codec for video live view

    private int count;

    /*-----------------------------------主界面控件----------------------------------*/
    private View mView;
    private MapView mapView;
    private AMap aMap;
    private PolylineOptions polylineOptions;

    private UiSettings uiSettings; // 地图UI设置
    private RelativeLayout mapContainer; // 右下角的布局容器
    private RelativeLayout dcontainer; // 与屏幕大小相同的布局容器
    private RelativeLayout cover; // 放置在右下角的布局容器中，用于点击切换地图和视频界面
    private boolean isMap;

    private CameraPosition cameraPosition;

    private View vview;
    private TextureView fpvWidget; // 视频控件，FPVWidget继承自TextureView

    private RecyclerView resultList; // 显示识别结果的列表控件
    private RecognitionResultAdapter adapter;
    private ArrayList<RecognitionResultItem> resultItemArrayList;

    // 下面是自己添加的按钮类控件
    private ImageView checkWaypointIv; // 查看航点

    private ImageView startIv; // 开始执行任务
    private boolean isStart = false;
    private ImageView disableSimulatorIv; // 关闭虚拟摇杆
    private ImageView landingIv;

    private boolean isNewMethod = false;
    private boolean isPIDMethod = true;
    private boolean isInitPid = false;
    private Button turnBtn;

    private ScheduledExecutorService scheduledExecutorService;
    /*-----------------------------------主界面控件----------------------------------*/


    //apriltags详情 抽屉
    private ImageButton mPushDrawerIb;
    private SlidingDrawer mPushInfoSd;
    private TextView mPushInfoTv;

    private TextView ltPushInfoTv;
    private TextView rtPushInfoTv;
    private TextView lbPushInfoTv;
    private TextView rbPushInfoTv;
    private TextView cPushInfoTv;

    // 物体识别
    private ImageView detectIv;

    private TextView ultrasonicTv;
    private TextView yawTv;
    private TextView pitchTv;
    private TextView angleTv;

    private double droneGDLocationLat = 36.667094, droneGDLocationLng = 117.140428; // 无人机坐标(高德)
    private float droneLocationHeight = 30f;
    private FlightController mFlightController;
    private Gimbal gimbal;
    private Battery battery;
    private Camera camera;
    public static WaypointMission.Builder waypointMissionBuilder;
    private float mSpeed = 10.0f;
    private WaypointMissionHeadingMode mHeadingMode = WaypointMissionHeadingMode.USING_WAYPOINT_HEADING;
    private WaypointMissionOperator waypointMissionOperator;

    // 飞机状态
    private LatLng sourceLatLng; // 无人机位置(真实坐标)
    private FlightMode flightMode; // 飞行模式
    private double roll;
    private double yaw;
    private double pitch;
    private int satelliteCount; // 卫星数
    private float velocityX; // X轴方向的速度
    private float velocityY; // Y轴方向的速度
    private float velocityZ; // Z轴方向的速度
    private float gimbalPitch; // 云台俯仰角
    private float gimbalYaw; // 云台水平角度
    private int batteryRemianing; // 剩余电量
    private int flightTime; // 已飞行的时间
    private Marker droneMarker = null;
    private String lastUploadTime = "2018-12-12 00:00:00";

    private boolean isTraceEnd;
    private long startTime;
    private float maxAltitude;
    private int imageCount;
    private boolean isRecord;
    private boolean isShot;
    private long videoStartTime;
    private long videoEndTime;
    private int videoLength; // 录像总时长
    private float distance;
    private String endTraceTime;
    private float pointCenterX;
    private double pointCenterY;
    private double hCenterX;
    private double hCenterY;
    private double angle = 0;

    private int height; // 移动设配屏幕的高度
    private int width; // 移动设配屏幕的宽度
    private float errX;
    private float errY;
    private float errXprecise;
    private float errYprecise;
    private float XDistance;
    private float YDistance;
    private float aircraftHeight;
    private float ultrasonicHeight;

    /*------------------------------下面是timeline飞行控制相关变量--------------------------------*/
    private MissionControl missionControl;
    private TimelineEvent preEvent;
    private TimelineElement preElement;
    private DJIError preError;
    private boolean isGetHome;
    protected double homeLatitude = 181; // 真实坐标
    protected double homeLongitude = 181; // 真实坐标
    protected double homeGDLatitude = 181; // 高德坐标
    protected double homeGDLongitude = 181; // 高德坐标
    /*-----------------------------上面是timeline飞行控制相关变量--------------------------------*/

    public boolean isDetection = false;

    OverlayView trackingOverlay;

    /*---------------------------AprilTag识别----------------------------*/
    private int id;
    public double center_x, center_y, left_top_x, left_top_y, right_top_x, right_top_y, right_bottom_x, right_bottom_y, left_bottom_x, left_bottom_y;
    double t_x = 0;
    double t_y = 0;
    double angle_z;
    double tagCenterX = 0;
    double tagCenterY = 0;

    float tagErrX = 300;
    float tagErrY = 300;
    private ArrayList<ApriltagPoseEstimation> mPoses;

    private double last_t_x = 0;
    private double last_t_y = 0;
    private double last_tagCenterX = 0;
    private double last_tagCenterY = 0;

    private boolean tagfirstLanding = false;
    private boolean tagsecondLanding = false;
    private boolean tagthirdLanding = false;
    private boolean tagforthLanding = false;

    private boolean tagFlag = false;
    Thread tagThread;
    private int[] rgbBytesAprilTag = null;

    private Handler handlerForAprilTags;
    private HandlerThread handlerThreadForAprilTags;
    private RecognizerForAprilTags recognizerForAprilTags;

    /*---------------------------停机坪识别相关--------------------------*/
    private byte[] luminanceCopy;

    // 借助TimerTask来定时发数据，timePeriod设为200ms  官方文档推荐app与遥控的通信频率在50Hz
    private float leftRight, frontBack, turnLeftRight, upDown;
    private Timer sendVirtualStickDataTimer;
    private SendVirtualStickDataTask sendVirtualStickDataTask;

    private float boxX;
    private float boxY;
    private float screenX;
    private float screenY;
    private float dX;
    private float dY;

    protected int previewWidth = 0; // 预览尺寸
    protected int previewHeight = 0;

    private static final Logger LOGGER = new Logger();

    private int yRowStride;

    private BorderedText borderedText;//字体组件
    private static final float TEXT_SIZE_DIP = 10; // 图像识别框下边的字体尺寸

    private enum DetectorMode {
        TF_OD_API, MULTIBOX, YOLO;
    }

    private static final DetectorMode MODE = DetectorMode.TF_OD_API;
    private static final boolean MAINTAIN_ASPECT = MODE == DetectorMode.YOLO;

    private Integer sensorOrientation = 90;  //手机可以获得，但是无人机发现90正好适配，可能存在隐患，保留，不清楚参数的详细背后逻辑
    private Bitmap rgbFrameBitmap = null;
    private Bitmap croppedBitmap = null; // 修剪后的Bitmap？
    private Bitmap cropCopyBitmap = null;// 修剪复制的Bitmap？
    private static final float MINIMUM_CONFIDENCE_TF_OD_API = 0.6f;
    private Matrix frameToCropTransform; // 框架到修剪的转换？
    private Matrix cropToFrameTransform; // 修剪到框架的转换？
    private long timestamp = 0;
    private static final boolean SAVE_PREVIEW_BITMAP = true;

    private boolean isSimulator = false;
    private boolean isLandingOpen = true;
    private boolean a = true;
    private boolean isLandingOpenToast = false;
    private boolean isTurnOpen = false;

    private long timestampForTarmac = 0;
    private Handler handlerForTarmac;
    private HandlerThread handlerThreadForTarmac;
    private MultiBoxTarmacTracker tarmacTracker;

    private int[] rgbBytesTarmac = null;

    private PIDControlIncTest pidControlIncTestX;
    private PIDControlIncTest pidControlIncTestY;
    private PIDControlIncTest pidControlIncTestTurn;
    private int adjustTimes = 0;

    private float controlValueIncX;
    private float controlValueIncY;
    private float controlValueIncTurn;

    private boolean firstLanding = false;
    private boolean secondLanding = false;
    private boolean thirdLanding = false;
    private boolean forthLanding = false;

    private boolean isTarmacTrackVisible = true;
    private boolean tarmacFlag = true;
    private int times;
    private TextView timesTv;
    private TextView resultTv;

    private boolean isTarmacRec;
    private boolean isPoppyRec;

    private Recognizer tarmacDetector;

    Thread tarmacThread;
    /**
     * 停机坪 线程
     */
    Runnable tarmacRunnable = new Runnable() {
        @Override
        public void run() {
            while (tarmacFlag) {
                times++;
                long start = System.currentTimeMillis();
                if (isTarmacRec) {
                    if (isLandingOpen) {
                        // 无人机与起飞点的相对高度大于1.5m时识别停机坪并调整位置，小于2m时直接降落
                        if (ultrasonicHeight > 0.5 && ultrasonicHeight <= 20) {   //3.0
                            Bitmap bitmap = fpvWidget.getBitmap();
                            if (bitmap != null) {
                                doTarmacRecognition(bitmap, "yolov2Tiny");
                            }
                        } else if (ultrasonicHeight <= 0.5) {   //3.1

                            if (tarmacThread != null && tarmacThread.isAlive()) {
                                tarmacFlag = false;
                                isDetection = false;
                                //                                trackingOverlay.setVisibility(View.INVISIBLE);
                                tarmacThread.interrupt();
                                tarmacDetector.close();
                                isTarmacTrackVisible = false;
                                isTarmacRec = false;
                                isPoppyRec = false;
                                if (trackingOverlay != null)
                                    trackingOverlay.setVisibility(View.INVISIBLE);
                            }

                            pidControlIncTestX.initPID(0.0001f, 0.000001f, 0.000001f);
                            pidControlIncTestY.initPID(0.0001f, 0.000001f, 0.000001f);

                            if (mFlightController != null) {
                                mFlightController.setVirtualStickModeEnabled(true, new CommonCallbacks.CompletionCallback() {
                                    @Override
                                    public void onResult(DJIError djiError) {
                                        if (djiError != null) {
                                            setResultToToast(djiError.getDescription());
                                        } else {
                                            isSimulator = true;
                                            runOnUiThread(new Runnable() {
                                                @Override
                                                public void run() {
                                                    disableSimulatorIv.setImageResource(R.mipmap.aircraft_mode);
                                                    //                                                                    setResultToToast("虚拟摇杆开启");
                                                }
                                            });
                                        }
                                    }
                                });
                            }

                            if (!tagFlag) {
                                Log.i("dongtagFlag", "onClick: tagRunnable");
                                tagFlag = true;
                                isDetection = true;
                                tagThread = new Thread(tagRunnable);
                                tagThread.start();
                                detectIv.setImageResource(R.mipmap.detect_open);
                                recognizerForAprilTags = new ApriltagsDetectAPIModel();
                            }


                        }
                        // 若无人机螺旋桨的电机已停止转动
                        /*if (!mFlightController.getState().areMotorsOn()) {
                            runOnUiThread(new Runnable() {
                                @Override
                                public void run() {
                                    setResultToToast("已安全降落!");
                                    tarmacFlag = false;
                                    isDetection = false;
                                    trackingOverlay.setVisibility(View.INVISIBLE);
                                    tarmacThread.interrupt();
                                    detectIv.setImageResource(R.mipmap.detect_close_u);
                                    //                                setResultToToast("识别停机坪图层关闭");
                                    isTarmacTrackVisible = false;
                                    // 关闭虚拟摇杆
                                    if (mFlightController != null) {
                                        mFlightController.setVirtualStickModeEnabled(false, new CommonCallbacks.CompletionCallback() {
                                            @Override
                                            public void onResult(DJIError djiError) {
                                                if (djiError != null) {
                                                    setResultToToast(djiError.getDescription());
                                                } else {
                                                    //                                                setResultToToast("虚拟摇杆关闭");
                                                }
                                            }
                                        });
                                    }
                                }
                            });
                        }*/
                    } else {
                        Bitmap bitmap = fpvWidget.getBitmap();
                        if (bitmap != null) {
                            doTarmacRecognition(bitmap, "yolov2Tiny");
                        }
                    }
                }

                long stop = System.currentTimeMillis();
                final long time = stop - start;
                Log.i("aaaaaaaaaaaaaaaa", "msg tarmac detect once");

                try {
                    Thread.sleep(300);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    };

    /**
     * 识别停机坪
     *
     * @param bitmap
     */
    private void doTarmacRecognition(Bitmap bitmap, String soName) {
        try {
            // Initialize the storage bitmaps once when the resolution is known.
            if (rgbBytesTarmac == null) {
                //预览尺寸
                previewHeight = bitmap.getHeight();
                previewWidth = bitmap.getWidth();
                rgbBytesTarmac = new int[previewHeight * previewWidth];
                onPreviewSizeChosenForTarmac(new Size(previewWidth, previewHeight), 90);
            }
        } catch (final Exception e) {
            LOGGER.e(e, "Exception!");
            return;
        }
        long s = System.currentTimeMillis();

        long t = System.currentTimeMillis() - s;
        Log.i("MainActivity", "执行完getNV21()的时间：" + t + "ms");

        yRowStride = previewWidth;

        long start = System.currentTimeMillis();

        processImageForTarmac(bitmap, soName);
        long time = System.currentTimeMillis() - start;
        Log.i("MainActivity", "执行完processImageForPlate的时间：" + time + "ms");
    }

    /**
     * 停机坪画框设置
     *
     * @param size
     * @param rotation
     */
    private void onPreviewSizeChosenForTarmac(final Size size, final int rotation) {
        final float textSizePx = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, TEXT_SIZE_DIP, getResources().getDisplayMetrics());
        borderedText = new BorderedText(textSizePx);//字体控件,参数是px值
        borderedText.setTypeface(Typeface.MONOSPACE);//设置字体

        tarmacTracker = new MultiBoxTarmacTracker(this);//方框

        int cropSize = 1000;//OD（物体检测）的输入尺寸大小，300*300
        //此处创建了识别器
        //        tarmacDetector = new TarmacDetectAPIModel(soName);

        previewWidth = size.getWidth(); //相机预览图的宽、高 // 这里要求android最小版本为21
        previewHeight = size.getHeight();

        sensorOrientation = rotation - getScreenOrientation(); // 90 - 屏幕旋转角度
        LOGGER.i("Camera orientation relative to screen canvas: %d", sensorOrientation);

        LOGGER.i("Initializing at size %dx%d", previewWidth, previewHeight);
        rgbFrameBitmap = Bitmap.createBitmap(previewWidth, previewHeight, Bitmap.Config.ARGB_8888);
        croppedBitmap = Bitmap.createBitmap(cropSize, cropSize, Bitmap.Config.ARGB_8888);

        // 获得一个Matrix变量
        // 这里的dstWidth和disHeight改为了previewWidth和previewHeigh
        //        frameToCropTransform = ImageUtils.getTransformationMatrix(
        //                previewWidth, previewHeight,
        //                previewWidth, previewHeight,
        //                sensorOrientation, MAINTAIN_ASPECT);

        //TODO
        frameToCropTransform = ImageUtils.getTransformationMatrix(previewWidth, previewHeight, previewWidth, previewHeight, sensorOrientation, MAINTAIN_ASPECT);

        cropToFrameTransform = new Matrix();
        frameToCropTransform.invert(cropToFrameTransform);

        trackingOverlay = (OverlayView) findViewById(R.id.tracking_overlay);
        trackingOverlay.addCallback(new OverlayView.DrawCallback() {
            @Override
            public void drawCallback(final Canvas canvas) {
                tarmacTracker.draw(canvas);
            }
        });
    }

    /**
     * 识别停机坪并处理识别后得到的数据
     *
     * @param bitmap
     */
    private void processImageForTarmac(final Bitmap bitmap, final String soName) {
        ++timestampForTarmac;
        final long currTimestamp = timestampForTarmac;
        byte[] originalLuminance = null;//亮度
        Log.e("OnFrameInfo", "" + previewHeight + " " + previewWidth + " " + getLuminanceStride() + " " + sensorOrientation + " " + originalLuminance + " " + timestampForTarmac);

        tarmacTracker.onFrame(previewWidth, previewHeight, getLuminanceStride(), sensorOrientation,//传感器方向
                originalLuminance, timestampForTarmac);

        if (trackingOverlay == null) {
            Log.i("MainActivity", "trackingOverlay is null");
        }
        trackingOverlay.postInvalidate();

        //下面这一句问题很大
        //imageConverter.run();
        rgbFrameBitmap = bitmap;

        final Canvas canvas = new Canvas(croppedBitmap);
        canvas.drawBitmap(rgbFrameBitmap, frameToCropTransform, null);

        long start = System.currentTimeMillis();
        runInBackgroundForTarmac(new Runnable() {
            @Override
            public void run() {
                LOGGER.i("Running tarmac detection on image " + currTimestamp);

                // 得到识别结果
                final List<Recognizer.Recognition> results = tarmacDetector.recognizeImage(bitmap);

                // 创建画布和画笔
                cropCopyBitmap = Bitmap.createBitmap(bitmap);
                final Canvas canvas = new Canvas(bitmap);
                final Paint paint = new Paint();
                paint.setColor(Color.RED);
                paint.setStyle(Paint.Style.STROKE);
                paint.setStrokeWidth(2.0f);

                float minimumConfidence = 0f;

                final List<Recognizer.Recognition> mappedRecognitions = new LinkedList<>();
                float rights = 0;
                float lefts = 0;
                float tops = 0;
                float bots = 0;
                float num = 0;
                float pointCenterX = 0;
                float pointCenterY = 0;
                float hCenterX = 0;
                float hCenterY = 0;
                for (final Recognizer.Recognition result : results) {
                    // 画框
                    /**
                     * 超声波高度
                     */
                    if (ultrasonicHeight > 3.0 && !result.getName().equals("H")) {
                        final RectF location = result.getLocation();
                        resultItemArrayList.add(new RecognitionResultItem(getTime(System.currentTimeMillis()), result.getName(), String.valueOf(result.getConfidence() * 100) + "%", String.valueOf(result.getTime()) + "ms", String.valueOf(result.getLeft()), String.valueOf(result.getTop()), String.valueOf(result.getRight()), String.valueOf(result.getBottom()), ""));
                        while (resultItemArrayList.size() > 5) {
                            resultItemArrayList.remove(0);
                        }
                        runOnUiThread(new Runnable() {
                            @Override
                            public void run() {
                                adapter.notifyDataSetChanged();

                            }
                        });
                        if (location != null && result.getConfidence() >= minimumConfidence) {
                            if (result.getName().equals("Helipad")) {
                                rights = result.getRight();
                                lefts = result.getLeft();
                                tops = result.getTop();
                                bots = result.getBottom();
                                //                            num += 1;
                            }
                            // 计算角度
                            if (result.getName().equals("O")) {
                                pointCenterX = (result.getRight() - result.getLeft()) / 2 + result.getLeft();
                                pointCenterY = (result.getBottom() - result.getTop()) / 2 + result.getTop();
                            }
                            if (result.getName().equals("Helipad")) {
                                hCenterX = (result.getRight() - result.getLeft()) / 2 + result.getLeft();
                                hCenterY = (result.getBottom() - result.getTop()) / 2 + result.getTop();
                            }
                            if (pointCenterX != 0 && pointCenterY != 0 && hCenterX != 0 && hCenterY != 0) {
                                if (pointCenterX > hCenterX && pointCenterY < hCenterY) { // 第一象限
                                    angle = Math.atan((pointCenterX - hCenterX) / (hCenterY - pointCenterY)) * 180 / Math.PI; // angle > 0
                                } else if (pointCenterX > hCenterX && pointCenterY > hCenterY) { // 第四象限
                                    angle = Math.atan((pointCenterY - hCenterY) / (pointCenterX - hCenterX)) * 180 / Math.PI + 90; // angle > 0
                                } else if (pointCenterX < hCenterX && pointCenterY > hCenterY) { // 第三象限
                                    angle = -(Math.atan((pointCenterY - hCenterY) / (hCenterX - pointCenterX)) * 180 / Math.PI + 90); // angle < 0
                                } else if (pointCenterX < hCenterX && pointCenterY < hCenterY) { // 第二象限
                                    angle = -Math.atan((hCenterX - pointCenterX) / (hCenterY - pointCenterY)) * 180 / Math.PI; // angle < 0
                                }
                            }

                            // 执行这一句后，框就画出来了！
                            // TODO 置信度>0.45的才会画框
                            canvas.drawRect(location, paint);

                            cropToFrameTransform.mapRect(location);//将location矩形进行了变换，将裁剪的图片转换成了原来的正常帧
                            result.setLocation(location);//存储正常帧的位置信息
                            mappedRecognitions.add(result);//匹配的矩形列表存储此结果
                        }
                    }
                    if (ultrasonicHeight <= 3.0 && !result.getName().equals("Helipad")) {
                        final RectF location = result.getLocation();
                        resultItemArrayList.add(new RecognitionResultItem(getTime(System.currentTimeMillis()), result.getName(), String.valueOf(result.getConfidence() * 100) + "%", String.valueOf(result.getTime()) + "ms", String.valueOf(result.getLeft()), String.valueOf(result.getTop()), String.valueOf(result.getRight()), String.valueOf(result.getBottom()), ""));
                        while (resultItemArrayList.size() > 5) {
                            resultItemArrayList.remove(0);
                        }
                        runOnUiThread(new Runnable() {
                            @Override
                            public void run() {
                                adapter.notifyDataSetChanged();
                            }
                        });
                        if (location != null) {
                            if (result.getName().equals("H")) {
                                rights = result.getRight();
                                lefts = result.getLeft();
                                tops = result.getTop();
                                bots = result.getBottom();
                                //                            num += 1;
                            }
                            // 计算角度
                            if (result.getName().equals("O")) {
                                pointCenterX = (result.getRight() - result.getLeft()) / 2 + result.getLeft();
                                pointCenterY = (result.getBottom() - result.getTop()) / 2 + result.getTop();
                            }
                            if (result.getName().equals("H")) {
                                hCenterX = (result.getRight() - result.getLeft()) / 2 + result.getLeft();
                                hCenterY = (result.getBottom() - result.getTop()) / 2 + result.getTop();
                            }
                            if (pointCenterX != 0 && pointCenterY != 0 && hCenterX != 0 && hCenterY != 0) {
                                if (pointCenterX > hCenterX && pointCenterY < hCenterY) { // 第一象限
                                    angle = Math.atan((pointCenterX - hCenterX) / (hCenterY - pointCenterY)) * 180 / Math.PI; // angle > 0
                                } else if (pointCenterX > hCenterX && pointCenterY > hCenterY) { // 第四象限
                                    angle = Math.atan((pointCenterY - hCenterY) / (pointCenterX - hCenterX)) * 180 / Math.PI + 90; // angle > 0
                                } else if (pointCenterX < hCenterX && pointCenterY > hCenterY) { // 第三象限
                                    angle = -(Math.atan((pointCenterY - hCenterY) / (hCenterX - pointCenterX)) * 180 / Math.PI + 90); // angle < 0
                                } else if (pointCenterX < hCenterX && pointCenterY < hCenterY) { // 第二象限
                                    angle = -Math.atan((hCenterX - pointCenterX) / (hCenterY - pointCenterY)) * 180 / Math.PI; // angle < 0
                                }
                            }

                            // 执行这一句后，框就画出来了！
                            // TODO 置信度>0.45的才会画框
                            canvas.drawRect(location, paint);

                            cropToFrameTransform.mapRect(location);//将location矩形进行了变换，将裁剪的图片转换成了原来的正常帧
                            result.setLocation(location);//存储正常帧的位置信息
                            mappedRecognitions.add(result);//匹配的矩形列表存储此结果
                        }
                    }
                }
                //for循环结束后，计算出的量：rights、lefts、tops、bots、angle
                if (soName.equals("yolov2Tiny")) {
                    if (isLandingOpen) {

                        // XDistance是画的方框的右侧边框与屏幕右侧的距离减去左侧边框与屏幕左侧的距离
                        XDistance = width - rights - lefts;
                        YDistance = height - bots - tops;

                        // boxX是方框的横向距离
                        boxX = (rights - lefts) / 2 + (lefts);
                        boxY = (bots - tops) / 2 + (tops);

                        dX = screenX - boxX; // X轴方向，方框中心与屏幕中心的距离差
                        dY = screenY - boxY;

                        controlValueIncTurn = pidControlIncTestTurn.pidRealize((float) angle);

                        // 增量式PID算法，计算x轴方向的控制量
                        if (ultrasonicHeight > 7.7) {
                            if (Math.abs(dX) >= errX) { // 距离差>=30像素时，需要调整水平位置，计算得到控制量
                                controlValueIncX = pidControlIncTestX.pidRealize(dX);
                                //                            controlValueIncX = (0-dX)*0.0008f;
                            } else if (firstLanding) { // 距离差<=30像素时，不调整水平位置，控制量清零，pid重新初始化
                                controlValueIncX = 0;
                                //                            pidControlTestX.initPID(0.000368f, 0.0000039f, 0.0001f);
                                //                                pidControlIncTestX.initPID(0.0009f, 0.00002f, 0.00001f);
                                pidControlIncTestX.initPID(0.0008f, 0.00002f, 0.00001f);
                            }
                            if (Math.abs(dY) >= errY) {
                                controlValueIncY = pidControlIncTestY.pidRealize(dY);
                                //                            controlValueIncY = (0-dY)*0.0008f;
                            } else if (firstLanding) {
                                controlValueIncY = 0;
                                //                            pidControlTestY.initPID(0.000368f, 0.0000039f, 0.0001f);
                                //                                pidControlIncTestY.initPID(0.0009f, 0.00002f, 0.00001f);
                                pidControlIncTestX.initPID(0.0008f, 0.00002f, 0.00001f);
                            }
                        }
                        if (ultrasonicHeight <= 7.7 && ultrasonicHeight > 5.2) {
                            if (Math.abs(dX) >= errX) { // 距离差>=30像素时，需要调整水平位置，计算得到控制量
                                controlValueIncX = pidControlIncTestX.pidRealize(dX);
                                //                            controlValueIncX = (0-dX)*0.0005f;
                            } else if (secondLanding) { // 距离差<=30像素时，不调整水平位置，控制量清零，pid重新初始化
                                controlValueIncX = 0;
                                //                            pidControlTestX.initPID(0.000165f, 0.00000125f, 0.00012f);
                                pidControlIncTestX.initPID(0.0003f, 0.000009f, 0.000009f);
                            }
                            if (Math.abs(dY) >= errY) {
                                controlValueIncY = pidControlIncTestY.pidRealize(dY);
                                //                            controlValueIncY = (0-dY)*0.0005f;
                            } else if (secondLanding) {
                                controlValueIncY = 0;
                                //                            pidControlTestY.initPID(0.000165f, 0.00000125f, 0.00012f);
                                pidControlIncTestY.initPID(0.0003f, 0.000009f, 0.000009f);
                            }
                        }
                        if (ultrasonicHeight <= 5.2 && ultrasonicHeight > 3.0) {
                            if (Math.abs(dX) >= errX) { // 距离差>=30像素时，需要调整水平位置，计算得到控制量
                                controlValueIncX = pidControlIncTestX.pidRealize(dX);
                            } else if (thirdLanding) { // 距离差<=30像素时，不调整水平位置，控制量清零，pid重新初始化
                                controlValueIncX = 0;
                                //                                pidControlIncTestX.initPID(0.00015f, 0.00001f, 0.0001f);
                                pidControlIncTestX.initPID(0.0001f, 0.000001f, 0.000001f);
                            }
                            if (Math.abs(dY) >= errY) {
                                controlValueIncY = pidControlIncTestY.pidRealize(dY);
                            } else if (thirdLanding) {
                                controlValueIncY = 0;
                                //                                pidControlIncTestY.initPID(0.00015f, 0.00001f, 0.0001f);
                                pidControlIncTestY.initPID(0.0001f, 0.000001f, 0.000001f);
                            }
                        }
                        if (ultrasonicHeight <= 3.0) {
                            if (Math.abs(dX) >= errXprecise) { // 距离差>=30像素时，需要调整水平位置，计算得到控制量
                                controlValueIncX = pidControlIncTestX.pidRealize(dX);
                            }
                            if (Math.abs(dY) >= errYprecise) {
                                controlValueIncY = pidControlIncTestY.pidRealize(dY);
                            }
                        }

                        // 将数据写入文件，包括每次识别后：停机坪框的中心与屏幕中心在x轴和y轴的距离差、无人机高度、x方向和y方向的控制量、当前时间
                        runOnUiThread(new Runnable() {
                            @Override
                            public void run() {
                                if (WriteFileUtil.isExternalStorageWritable()) {
                                    String status = Environment.getExternalStorageState();
                                    if (status.equals(Environment.MEDIA_MOUNTED)) {
                                        File dir = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/droneplus/");
                                        if (!dir.exists()) {
                                            dir.mkdir();
                                        }
                                        WriteFileUtil.putStringToExternalStorage(dX + "\r\n", dir, "x.txt", true);
                                        WriteFileUtil.putStringToExternalStorage(dY + "\r\n", dir, "y.txt", true);
                                        WriteFileUtil.putStringToExternalStorage(ultrasonicHeight + "\r\n", dir, "height.txt", true);
                                        WriteFileUtil.putStringToExternalStorage(controlValueIncX + "\r\n", dir, "PIDx.txt", true);
                                        WriteFileUtil.putStringToExternalStorage(controlValueIncY + "\r\n", dir, "PIDy.txt", true);
                                        //                                        WriteFileUtil.putStringToExternalStorage(controlValueIncTurn+"\r\n", dir, "PID_turn.txt", true);
                                        WriteFileUtil.putStringToExternalStorage(currentTime() + "\r\n", dir, "time.txt", true);
                                        WriteFileUtil.putStringToExternalStorage(angle + "\r\n", dir, "angle_tr.txt", true);
                                    }
                                }
                            }
                        });
                        if (pointCenterX != 0) { // 识别到了方向标志
                            if (Math.abs(angle) > 1) {
                                if (angle > 0 && angle < 180) {
                                    if (mFlightController != null) { // 向左转
                                        runOnUiThread(new Runnable() {
                                            @Override
                                            public void run() {
                                                angleTv.setText(controlValueIncTurn + "");
                                                if (WriteFileUtil.isExternalStorageWritable()) {
                                                    String status = Environment.getExternalStorageState();
                                                    if (status.equals(Environment.MEDIA_MOUNTED)) {
                                                        File dir = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/droneplus/");
                                                        if (!dir.exists()) {
                                                            dir.mkdir();
                                                        }
                                                        WriteFileUtil.putStringToExternalStorage(controlValueIncTurn + "\r\n", dir, "PID_turn.txt", true);
                                                    }
                                                }
                                            }
                                        });
                                        flyControl(0, 0, Math.abs(controlValueIncTurn), 0);
                                    }
                                }
                                if (angle < 0 && angle > -180) {
                                    if (mFlightController != null) { // 向右转
                                        runOnUiThread(new Runnable() {
                                            @Override
                                            public void run() {
                                                angleTv.setText(controlValueIncTurn + "");
                                                if (WriteFileUtil.isExternalStorageWritable()) {
                                                    String status = Environment.getExternalStorageState();
                                                    if (status.equals(Environment.MEDIA_MOUNTED)) {
                                                        File dir = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/droneplus/");
                                                        if (!dir.exists()) {
                                                            dir.mkdir();
                                                        }
                                                        WriteFileUtil.putStringToExternalStorage(controlValueIncTurn + "\r\n", dir, "PID_turn.txt", true);
                                                    }
                                                }
                                            }
                                        });
                                        flyControl(0, 0, -Math.abs(controlValueIncTurn), 0);
                                    }
                                }
                            }
                        }
                        if (XDistance != width && YDistance != height) { // 识别成功，出现偏移距离
//                            if (TaskActivity.adjustMode == 0) {
                                if (ultrasonicHeight > 7.7) { // 7.7m以上调整一次
                                    if (isPIDMethod) {
                                        // 第一象限
                                        if (XDistance < 0 && YDistance > 0) {
                                            if ((Math.abs(dX) >= errX || Math.abs(dY) >= errY) && !firstLanding) {
                                                //                                                adjustTimes = 0;
                                                //                                            flyControl(Math.abs(controlValueX), Math.abs(controlValueY), 0, 0);
                                                flyControl(Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, 0);
                                            }
                                            if ((Math.abs(dX) < errX && Math.abs(dY) < errY) && !firstLanding) {
                                                //                                                adjustTimes++;
                                                //                                                if (adjustTimes >= 3) {
                                                //                                                    firstLanding = true;
                                                //                                                    adjustTimes = 0;
                                                //                                                }
                                                firstLanding = true;
                                            }
                                            if (firstLanding) {
                                                if (ultrasonicHeight > 2) {
                                                    flyControl(0, 0, 0, -0.5f);
                                                }
                                            }
                                        }
                                        // 第二象限
                                        if (XDistance > 0 && YDistance > 0) {
                                            if ((Math.abs(dX) >= errX || Math.abs(dY) >= errY) && !firstLanding) {
                                                //                                                adjustTimes = 0;
                                                //                                            flyControl((-1)*Math.abs(controlValueX), Math.abs(controlValueY), 0, 0);
                                                flyControl((-1) * Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, 0);
                                            }
                                            if ((Math.abs(dX) < errX && Math.abs(dY) < errY) && !firstLanding) {
                                                //                                                adjustTimes++;
                                                //                                                if (adjustTimes >= 3) {
                                                //                                                    firstLanding = true;
                                                //                                                    adjustTimes = 0;
                                                //                                                }
                                                firstLanding = true;
                                            }
                                            if (firstLanding) {
                                                if (ultrasonicHeight > 2) {
                                                    flyControl(0, 0, 0, -0.5f);
                                                }
                                            }
                                        }
                                        // 第三象限
                                        if (XDistance > 0 && YDistance < 0) {
                                            if ((Math.abs(dX) >= errX || Math.abs(dY) >= errY) && !firstLanding) {
                                                //                                                adjustTimes = 0;
                                                //                                            flyControl((-1)*Math.abs(controlValueX), (-1)*Math.abs(controlValueY), 0, 0);
                                                flyControl((-1) * Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, 0);
                                            }
                                            if ((Math.abs(dX) < errX && Math.abs(dY) < errY) && !firstLanding) {
                                                //                                                adjustTimes++;
                                                //                                                if (adjustTimes >= 3) {
                                                //                                                    firstLanding = true;
                                                //                                                    adjustTimes = 0;
                                                //                                                }
                                                firstLanding = true;
                                            }
                                            if (firstLanding) {
                                                if (ultrasonicHeight > 2) {
                                                    flyControl(0, 0, 0, -0.5f);
                                                }
                                            }
                                        }
                                        // 第四象限
                                        if (XDistance < 0 && YDistance < 0) {
                                            if ((Math.abs(dX) >= errX || Math.abs(dY) >= errY) && !firstLanding) {
                                                //                                                adjustTimes = 0;
                                                //                                            flyControl(Math.abs(controlValueX), (-1)*Math.abs(controlValueY), 0, 0);
                                                flyControl(Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, 0);
                                            }
                                            if ((Math.abs(dX) < errX && Math.abs(dY) < errY) && !firstLanding) {
                                                //                                                adjustTimes++;
                                                //                                                if (adjustTimes >= 3) {
                                                //                                                    firstLanding = true;
                                                //                                                    adjustTimes = 0;
                                                //                                                }
                                                firstLanding = true;
                                            }
                                            if (firstLanding) {
                                                if (ultrasonicHeight > 2) {
                                                    flyControl(0, 0, 0, -0.5f);
                                                }
                                            }
                                        }
                                    }
                                }

                                if (ultrasonicHeight <= 7.7 && ultrasonicHeight > 5.2) { // 7.5m调整一次
                                    if (isPIDMethod) {
                                        // 第一象限
                                        if (XDistance < 0 && YDistance > 0) {
                                            if ((Math.abs(dX) >= errX || Math.abs(dY) >= errY) && !secondLanding) {
                                                //                                                adjustTimes = 0;
                                                //                                            flyControl(Math.abs(controlValueX), Math.abs(controlValueY), 0, 0);
                                                flyControl(Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, 0);
                                            }
                                            if ((Math.abs(dX) < errX && Math.abs(dY) < errY) && !secondLanding) {
                                                //                                                adjustTimes++;
                                                //                                                if (adjustTimes >= 3) {
                                                //                                                    secondLanding = true;
                                                //                                                    adjustTimes = 0;
                                                //                                                }
                                                secondLanding = true;
                                            }
                                            if (secondLanding) {
                                                if (ultrasonicHeight > 2) {
                                                    flyControl(0, 0, 0, -0.5f);
                                                }
                                            }
                                        }
                                        // 第二象限
                                        if (XDistance > 0 && YDistance > 0) {
                                            if ((Math.abs(dX) >= errX || Math.abs(dY) >= errY) && !secondLanding) {

                                                flyControl((-1) * Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, 0);
                                            }
                                            if ((Math.abs(dX) < errX && Math.abs(dY) < errY) && !secondLanding) {

                                                secondLanding = true;
                                            }
                                            if (secondLanding) {
                                                if (ultrasonicHeight > 2) {
                                                    flyControl(0, 0, 0, -0.5f);
                                                }
                                            }
                                        }
                                        // 第三象限
                                        if (XDistance > 0 && YDistance < 0) {
                                            if ((Math.abs(dX) >= errX || Math.abs(dY) >= errY) && !secondLanding) {

                                                flyControl((-1) * Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, 0);
                                            }
                                            if ((Math.abs(dX) < errX && Math.abs(dY) < errY) && !secondLanding) {

                                                secondLanding = true;
                                            }
                                            if (secondLanding) {
                                                if (ultrasonicHeight > 2) {
                                                    flyControl(0, 0, 0, -0.5f);
                                                }
                                            }
                                        }
                                        // 第四象限
                                        if (XDistance < 0 && YDistance < 0) {
                                            if ((Math.abs(dX) >= errX || Math.abs(dY) >= errY) && !secondLanding) {

                                                flyControl(Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, 0);
                                            }
                                            if ((Math.abs(dX) < errX && Math.abs(dY) < errY) && !secondLanding) {

                                                secondLanding = true;
                                            }
                                            if (secondLanding) {
                                                if (ultrasonicHeight > 2) {
                                                    flyControl(0, 0, 0, -0.5f);
                                                }
                                            }
                                        }
                                    }
                                }

                                if (ultrasonicHeight <= 5.2 && ultrasonicHeight > 3.0) { // 5m调整一次
                                    if (isPIDMethod) {
                                        // 第一象限
                                        if (XDistance < 0 && YDistance > 0) {
                                            if ((Math.abs(dX) >= errX || Math.abs(dY) >= errY) && !thirdLanding) {

                                                flyControl(Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, 0);
                                            }
                                            if ((Math.abs(dX) < errX && Math.abs(dY) < errY) && !thirdLanding) {

                                                thirdLanding = true;
                                            }
                                            if (thirdLanding) {
                                                if (ultrasonicHeight > 2) {
                                                    flyControl(0, 0, 0, -0.5f);
                                                }
                                            }
                                        }
                                        // 第二象限
                                        if (XDistance > 0 && YDistance > 0) {
                                            if ((Math.abs(dX) >= errX || Math.abs(dY) >= errY) && !thirdLanding) {

                                                flyControl((-1) * Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, 0);
                                            }
                                            if ((Math.abs(dX) < errX && Math.abs(dY) < errY) && !thirdLanding) {

                                                thirdLanding = true;
                                            }
                                            if (thirdLanding) {
                                                if (ultrasonicHeight > 2) {
                                                    flyControl(0, 0, 0, -0.5f);
                                                }
                                            }
                                        }
                                        // 第三象限
                                        if (XDistance > 0 && YDistance < 0) {
                                            if ((Math.abs(dX) >= errX || Math.abs(dY) >= errY) && !thirdLanding) {

                                                flyControl((-1) * Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, 0);
                                            }
                                            if ((Math.abs(dX) < errX && Math.abs(dY) < errY) && !thirdLanding) {

                                                thirdLanding = true;
                                            }
                                            if (thirdLanding) {
                                                if (ultrasonicHeight > 2) {
                                                    flyControl(0, 0, 0, -0.5f);
                                                }
                                            }
                                        }
                                        // 第四象限
                                        if (XDistance < 0 && YDistance < 0) {
                                            if ((Math.abs(dX) >= errX || Math.abs(dY) >= errY) && !thirdLanding) {

                                                flyControl(Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, 0);
                                            }
                                            if ((Math.abs(dX) < errX && Math.abs(dY) < errY) && !thirdLanding) {

                                                thirdLanding = true;
                                            }
                                            if (thirdLanding) {
                                                if (ultrasonicHeight > 2) {
                                                    flyControl(0, 0, 0, -0.5f);
                                                }
                                            }
                                        }
                                    }
                                }

/*                                if (ultrasonicHeight <= 3.0) { // 3m-2m调整一次
                                    if (isPIDMethod) {
                                        // 第一象限
                                        if (XDistance < 0 && YDistance > 0) {
                                            if ((Math.abs(dX) >= (errXprecise * 2) || Math.abs(dY) >= (errXprecise * 2)) && !forthLanding) {
                                                adjustTimes = 0;
                                                //                                            flyControl(Math.abs(controlValueX), Math.abs(controlValueY), 0, 0);
                                                flyControl(Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, 0);
                                            }
                                            if ((Math.abs(dX) < (errXprecise * 2) && Math.abs(dY) < (errYprecise * 2)) && !forthLanding) {
                                                adjustTimes++;
                                                if (adjustTimes >= 3) {
                                                    forthLanding = true;
                                                    adjustTimes = 0;
                                                }
                                                //                                                forthLanding = true;
                                            }
                                            if (forthLanding) {
                                                if (ultrasonicHeight > 2) {
                                                    flyControl(0, 0, 0, -0.3f);
                                                }
                                            }
                                        }
                                        // 第二象限
                                        if (XDistance > 0 && YDistance > 0) {
                                            if ((Math.abs(dX) >= (errXprecise * 2) || Math.abs(dY) >= (errXprecise * 2)) && !forthLanding) {
                                                adjustTimes = 0;
                                                //                                            flyControl((-1)*Math.abs(controlValueX), Math.abs(controlValueY), 0, 0);
                                                flyControl((-1) * Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, 0);
                                            }
                                            if ((Math.abs(dX) < (errXprecise * 2) && Math.abs(dY) < (errYprecise * 2)) && !forthLanding) {
                                                adjustTimes++;
                                                if (adjustTimes >= 3) {
                                                    forthLanding = true;
                                                    adjustTimes = 0;
                                                }
                                                //                                                forthLanding = true;
                                            }
                                            if (forthLanding) {
                                                if (ultrasonicHeight > 2) {
                                                    flyControl(0, 0, 0, -0.3f);
                                                }
                                            }
                                        }
                                        // 第三象限
                                        if (XDistance > 0 && YDistance < 0) {
                                            if ((Math.abs(dX) >= (errXprecise * 2) || Math.abs(dY) >= (errXprecise * 2)) && !forthLanding) {
                                                adjustTimes = 0;
                                                //                                            flyControl((-1)*Math.abs(controlValueX), (-1)*Math.abs(controlValueY), 0, 0);
                                                flyControl((-1) * Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, 0);
                                            }
                                            if ((Math.abs(dX) < (errXprecise * 2) && Math.abs(dY) < (errYprecise * 2)) && !forthLanding) {
                                                adjustTimes++;
                                                if (adjustTimes >= 3) {
                                                    forthLanding = true;
                                                    adjustTimes = 0;
                                                }
                                                //                                                forthLanding = true;
                                            }
                                            if (forthLanding) {
                                                if (ultrasonicHeight > 2) {
                                                    flyControl(0, 0, 0, -0.3f);
                                                }
                                            }
                                        }
                                        // 第四象限
                                        if (XDistance < 0 && YDistance < 0) {
                                            if ((Math.abs(dX) >= (errXprecise * 2) || Math.abs(dY) >= (errXprecise * 2)) && !forthLanding) {
                                                adjustTimes = 0;
                                                //                                            flyControl(Math.abs(controlValueX), (-1)*Math.abs(controlValueY), 0, 0);
                                                flyControl(Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, 0);
                                            }
                                            if ((Math.abs(dX) < (errXprecise * 2) && Math.abs(dY) < (errYprecise * 2)) && !forthLanding) {
                                                adjustTimes++;
                                                if (adjustTimes >= 3) {
                                                    forthLanding = true;
                                                    adjustTimes = 0;
                                                }
                                                //                                                forthLanding = true;
                                            }
                                            if (forthLanding) {
                                                if (ultrasonicHeight > 2) {
                                                    flyControl(0, 0, 0, -0.3f);
                                                }
                                            }
                                        }
                                    }
                                }*/

                                /*if (ultrasonicHeight <= 3.0)
                                {
                                    recognitionApriltags(bitmap);
                                }*/

//                            }
                        }
                    } else {
                        if (isLandingOpenToast) {
                            runOnUiThread(new Runnable() {
                                @Override
                                public void run() {
                                    setResultToToast("降落功能关闭");
                                }
                            });
                            isLandingOpenToast = false;
                        }
                    }
                }
                tarmacTracker.trackResults(mappedRecognitions, luminanceCopy, currTimestamp);
                trackingOverlay.postInvalidate();
            }
        });
        long time = System.currentTimeMillis() - start;
        Log.i("MainActivity", "执行完runInBackgroundForPlate的时间：" + time + "ms");
    }

    private double cx, cy, ltx, lty, lbx, lby, rtx, rty, rbx, rby;
    private double ltdx, ltdy, lbdx, lbdy, rtdx, rtdy, rbdx, rbdy, cdx, cdy;

    private double ctx, cty;

    private int left_top_id;
    private double left_top_center_x, left_top_center_y, left_top_t_x, left_top_t_y;
    private int right_top_id;
    private double right_top_center_x, right_top_center_y, right_top_t_x, right_top_t_y;
    private int left_bottom_id;
    private double left_bottom_center_x, left_bottom_center_y, left_bottom_t_x, left_bottom_t_y;
    private int right_bottom_id;
    private double right_bottom_center_x, right_bottom_center_y, right_bottom_t_x, right_bottom_t_y;
    private int center_id;
    private double center_center_x, center_center_y, center_t_x, center_t_y;


    //    判断是否之前已经识别过ID为0的标签
    private boolean notfirstRec0 = false;

    public void writeAprilTagsStatus(final int id, final double t_x, final double t_y, final float dX, final float dY, final float ultrasonicHeight, final float controlValueIncX, final float controlValueIncY, final double angle_z) {
        // 将数据写入文件，包括每次识别后：停机坪框的中心与屏幕中心在x轴和y轴的距离差、无人机高度、x方向和y方向的控制量、当前时间
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                if (WriteFileUtil.isExternalStorageWritable()) {
                    String status = Environment.getExternalStorageState();
                    if (status.equals(Environment.MEDIA_MOUNTED)) {
                        File dir = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/droneplus/");
                        if (!dir.exists()) {
                            dir.mkdir();
                        }
                        WriteFileUtil.putStringToExternalStorage(t_x + "\r\n", dir, "t_x_tag_" + id + ".txt", true);
                        WriteFileUtil.putStringToExternalStorage(t_y + "\r\n", dir, "t_y_tag_" + id + ".txt", true);
                        WriteFileUtil.putStringToExternalStorage(dX + "\r\n", dir, "dx_tag_" + id + ".txt", true);
                        WriteFileUtil.putStringToExternalStorage(dY + "\r\n", dir, "dy_tag_" + id + ".txt", true);
                        WriteFileUtil.putStringToExternalStorage(ultrasonicHeight + "\r\n", dir, "height_tag_" + id + ".txt", true);
                        WriteFileUtil.putStringToExternalStorage(controlValueIncX + "\r\n", dir, "PIDx_tag_" + id + ".txt", true);
                        WriteFileUtil.putStringToExternalStorage(controlValueIncY + "\r\n", dir, "PIDy_tag_" + id + ".txt", true);
                        //                                        WriteFileUtil.putStringToExternalStorage(controlValueIncTurn+"\r\n", dir, "PID_turn.txt", true);
                        WriteFileUtil.putStringToExternalStorage(currentTime() + "\r\n", dir, "time_tag_" + id + ".txt", true);
                        WriteFileUtil.putStringToExternalStorage(angle_z + "\r\n", dir, "angle_z_tag_" + id + ".txt", true);
                    }
                }
            }
        });
    }


    /**
     * AprilTags 线程
     */
    Runnable tagRunnable = new Runnable() {
        @Override
        public void run() {
            //            long start = System.currentTimeMillis();
            while (tagFlag) {

                if (ultrasonicHeight >= 0.0) {   //0.6

                    runInBackgroundForAprilTags(new Runnable() {
                        @Override
                        public void run() {

                            Log.i("dongrun", "run: ");
                            List<RecognizerForAprilTags.Recognition> results = null;

                            if (recognizerForAprilTags != null) {
                                results = recognizerForAprilTags.recognizeImage(fpvWidget.getBitmap());
                                Log.i("dongnotfindmark", "recognizerForAprilTags != null");
                            }

                            if (results != null) {
                                Log.i("dongnotfindmark", "results != null : results.size(): " + results.size());

                                if (results.size() < 2 && notfirstRec0) {

                                    if (results.size() == 1 && results.get(0).getId() != 0){}
                                    // 无人机已经无法获取到mark位置, 控制无人机朝最后一次记录的位置移动

                                    Log.i("dongnotfindmark", "results.size() < 2");
                                    pidControlIncTestX.initPID(0.0001f, 0.000001f, 0.000001f);
                                    pidControlIncTestY.initPID(0.0001f, 0.000001f, 0.000001f);

                                    //                                    if (notfirstRec0 && results.size() < 3) {
                                    if (ultrasonicHeight > 0.5 && ultrasonicHeight < 2.0) {

                                        // X轴方向，方框中心与屏幕中心的距离差
                                        dX = (float) last_tagCenterX;
                                        dY = (float) last_tagCenterY;

                                        Log.i("dongdXdY", "dX : " + dX + " dY: " + dY);

                                        // 增量式PID算法，计算x轴方向的控制量

                                        controlValueIncX = pidControlIncTestX.pidRealize(dX);
                                        controlValueIncY = pidControlIncTestY.pidRealize(dY);

                                        Log.i("dongnotfindmark", "run: last_t_x: " + last_t_x + " last_t_y: " + last_t_y);
                                        Log.i("dongnotfindmark", "run: controlValueIncX: " + controlValueIncX + " controlValueIncY: " + controlValueIncY);

                                        // 第一象限
                                        if (last_t_x < 0 && last_t_y > 0) {
                                            if (ultrasonicHeight > 0 && ultrasonicHeight < 2.0) {
                                                flyControl((-1) * Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, 0.1f);
                                            } else {
                                                flyControl((-1) * Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, 0);
                                            }
                                        }
                                        // 第二象限
                                        if (last_t_x > 0 && last_t_y > 0) {
                                            if (ultrasonicHeight > 0 && ultrasonicHeight < 2.0) {
                                                flyControl(Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, 0.1f);
                                            } else {
                                                flyControl(Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, 0);
                                            }
                                        }
                                        // 第三象限
                                        if (last_t_x > 0 && last_t_y < 0) {
                                            if (ultrasonicHeight > 0 && ultrasonicHeight < 2.0) {
                                                flyControl(Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, 0.1f);
                                            } else {
                                                flyControl(Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, 0);
                                            }
                                        }
                                        // 第四象限
                                        if (last_t_x < 0 && last_t_y < 0) {
                                            if (ultrasonicHeight > 0 && ultrasonicHeight < 2.0) {
                                                flyControl((-1) * Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, 0.1f);
                                            } else {
                                                flyControl((-1) * Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, 0);
                                            }
                                        }
                                        //                                        }
                                    }
                                } else {

                                    for (final RecognizerForAprilTags.Recognition result : results) {

                                        resultItemArrayList.add(new RecognitionResultItem(String.valueOf(new BigDecimal(result.getAngle_z()).setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue()) + "°", "x:" + String.valueOf(new BigDecimal(result.getT_x()).setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue()) + "cm", "y:" + String.valueOf(new BigDecimal(result.getT_y()).setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue()) + "cm", "id:" + result.id, "", "", "", "", ""));
                                        while (resultItemArrayList.size() > 5) {
                                            resultItemArrayList.remove(0);
                                        }

                                        runOnUiThread(new Runnable() {
                                            @Override
                                            public void run() {
                                                adapter.notifyDataSetChanged();
                                            }
                                        });

                                        Log.i("aprilID", "run: " + result.id);
                                        StringBuffer sb = new StringBuffer();

                                        switch (result.id) {
                                            case 1:

                                                ltx = result.getCenter_x();
                                                lty = result.getCenter_y();

                                                ltdx = Math.abs(ltx - screenX);
                                                ltdy = Math.abs(lty - screenY);

                                                left_top_t_x = result.getT_x();
                                                left_top_t_y = result.getT_y();

                                                LogUtil.addLineToSB(sb, "左上标签: ", result.id == 1 ? 1 : "");
                                                LogUtil.addLineToSB(sb, "center_x: ", Math.round(result.getCenter_x() * 100) / 100);
                                                LogUtil.addLineToSB(sb, "center_y: ", Math.round(result.getCenter_y() * 100) / 100);
                                                LogUtil.addLineToSB(sb, "t_x: ", Math.round(result.getT_x() * 100) / 100);
                                                LogUtil.addLineToSB(sb, "t_y: ", Math.round(result.getT_y() * 100) / 100);
                                                LogUtil.addLineToSB(sb, "距离屏幕中心 x(px): ", Math.round((screenX - result.getCenter_x()) * 100) / 100);
                                                LogUtil.addLineToSB(sb, "距离屏幕中心 y(px): ", Math.round((screenY - result.getCenter_y()) * 100) / 100);

                                                LogUtil.addLineToSB(sb, "与中心标签距离 x(px): ", Math.round((ltx - cx) * 100) / 100);
                                                LogUtil.addLineToSB(sb, "与中心标签距离 y(px): ", Math.round((lty - cy) * 100) / 100);

                                                writeAprilTagsStatus(result.id, result.getT_x(), result.getT_y(), (float) (screenX - result.getCenter_x()), (float) (screenY - result.getCenter_y()), ultrasonicHeight, pidControlIncTestX.pidRealize((float) (screenX - result.getCenter_x())), pidControlIncTestY.pidRealize((float) (screenY - result.getCenter_y())), result.getAngle_z());
                                                break;
                                            case 25:
                                                lbx = result.getCenter_x();
                                                lby = result.getCenter_y();

                                                lbdx = Math.abs(lbx - screenX);
                                                lbdy = Math.abs(lby - screenY);

                                                left_bottom_t_x = result.getT_x();
                                                left_bottom_t_y = result.getT_y();

                                                LogUtil.addLineToSB(sb, "左下标签", result.id == 25 ? 25 : "");
                                                LogUtil.addLineToSB(sb, "center_x: ", Math.round(result.getCenter_x() * 100) / 100);
                                                LogUtil.addLineToSB(sb, "center_y: ", Math.round(result.getCenter_y() * 100) / 100);
                                                LogUtil.addLineToSB(sb, "t_x: ", Math.round(result.getT_x() * 100) / 100);
                                                LogUtil.addLineToSB(sb, "t_y: ", Math.round(result.getT_y() * 100) / 100);
                                                LogUtil.addLineToSB(sb, "距离屏幕中心 x(px): ", Math.round((screenX - result.getCenter_x()) * 100) / 100);
                                                LogUtil.addLineToSB(sb, "距离屏幕中心 y(px): ", Math.round((screenY - result.getCenter_y()) * 100) / 100);

                                                LogUtil.addLineToSB(sb, "与中心标签距离 x(px): ", Math.round((lbx - cx) * 100) / 100);
                                                LogUtil.addLineToSB(sb, "与中心标签距离 y(px): ", Math.round((lby - cy) * 100) / 100);

                                                writeAprilTagsStatus(result.id, result.getT_x(), result.getT_y(), (float) (screenX - result.getCenter_x()), (float) (screenY - result.getCenter_y()), ultrasonicHeight, pidControlIncTestX.pidRealize((float) (screenX - result.getCenter_x())), pidControlIncTestY.pidRealize((float) (screenY - result.getCenter_y())), result.getAngle_z());
                                                break;
                                            case 2:
                                                rtx = result.getCenter_x();
                                                rty = result.getCenter_y();

                                                rtdx = Math.abs(rtx - screenX);
                                                rtdy = Math.abs(rty - screenY);

                                                right_top_t_x = result.getT_x();
                                                right_top_t_y = result.getT_y();

                                                LogUtil.addLineToSB(sb, "右上标签: ", result.id == 2 ? 2 : "");
                                                LogUtil.addLineToSB(sb, "center_x: ", Math.round(result.getCenter_x() * 100) / 100);
                                                LogUtil.addLineToSB(sb, "center_y: ", Math.round(result.getCenter_y() * 100) / 100);
                                                LogUtil.addLineToSB(sb, "t_x: ", Math.round(result.getT_x() * 100) / 100);
                                                LogUtil.addLineToSB(sb, "t_y: ", Math.round(result.getT_y() * 100) / 100);
                                                LogUtil.addLineToSB(sb, "距离屏幕中心 x(px): ", Math.round((screenX - result.getCenter_x()) * 100) / 100);
                                                LogUtil.addLineToSB(sb, "距离屏幕中心 y(px): ", Math.round((screenY - result.getCenter_y()) * 100) / 100);

                                                LogUtil.addLineToSB(sb, "与中心标签距离 x(px): ", Math.round((rtx - cx) * 100) / 100);
                                                LogUtil.addLineToSB(sb, "与中心标签距离 y(px): ", Math.round((rty - cy) * 100) / 100);

                                                writeAprilTagsStatus(result.id, result.getT_x(), result.getT_y(), (float) (screenX - result.getCenter_x()), (float) (screenY - result.getCenter_y()), ultrasonicHeight, pidControlIncTestX.pidRealize((float) (screenX - result.getCenter_x())), pidControlIncTestY.pidRealize((float) (screenY - result.getCenter_y())), result.getAngle_z());
                                                break;
                                            case 3:
                                                rbx = result.getCenter_x();
                                                rby = result.getCenter_y();

                                                rbdx = Math.abs(rbx - screenX);
                                                rbdy = Math.abs(rby - screenY);

                                                right_bottom_t_x = result.getT_x();
                                                right_bottom_t_y = result.getT_y();

                                                LogUtil.addLineToSB(sb, "右下标签", result.id == 3 ? 3 : "");
                                                LogUtil.addLineToSB(sb, "center_x: ", Math.round(result.getCenter_x() * 100) / 100);
                                                LogUtil.addLineToSB(sb, "center_y: ", Math.round(result.getCenter_y() * 100) / 100);
                                                LogUtil.addLineToSB(sb, "t_x: ", Math.round(result.getT_x() * 100) / 100);
                                                LogUtil.addLineToSB(sb, "t_y: ", Math.round(result.getT_y() * 100) / 100);
                                                LogUtil.addLineToSB(sb, "距离屏幕中心 x(px): ", Math.round((screenX - result.getCenter_x()) * 100) / 100);
                                                LogUtil.addLineToSB(sb, "距离屏幕中心 y(px): ", Math.round((screenY - result.getCenter_y()) * 100) / 100);
                                                LogUtil.addLineToSB(sb, "z轴方向倾角: ", result.getAngle_z());
                                                LogUtil.addLineToSB(sb, "与中心标签距离 x(px): ", Math.round((rbx - cx) * 100) / 100);
                                                LogUtil.addLineToSB(sb, "与中心标签距离 y(px): ", Math.round((rby - cy) * 100) / 100);

                                                writeAprilTagsStatus(result.id, result.getT_x(), result.getT_y(), (float) (screenX - result.getCenter_x()), (float) (screenY - result.getCenter_y()), ultrasonicHeight, pidControlIncTestX.pidRealize((float) (screenX - result.getCenter_x())), pidControlIncTestY.pidRealize((float) (screenY - result.getCenter_y())), result.getAngle_z());
                                                break;
                                            case 0:
                                                notfirstRec0 = true;

                                                cx = result.getCenter_x();
                                                cy = result.getCenter_y();
                                                ctx = result.getT_x();
                                                cty = result.getT_y();

                                                cdx = screenX - cx;
                                                cdy = screenY - cy;

                                                tagCenterX = result.getCenter_x();
                                                tagCenterY = result.getCenter_y();

                                                angle_z = result.getAngle_z();

                                                t_x = result.getT_x();
                                                t_y = result.getT_y();

                                                Log.i("case0", "run: t_x: " + t_x + " t_y: " + t_y);


                                                LogUtil.addLineToSB(sb, "中间标签:", result.id == 0 ? 0 : "");
                                                LogUtil.addLineToSB(sb, "center_x: ", Math.round(result.getCenter_x() * 100) / 100);
                                                LogUtil.addLineToSB(sb, "center_y: ", Math.round(result.getCenter_y() * 100) / 100);
                                                LogUtil.addLineToSB(sb, "t_x: ", Math.round(result.getT_x() * 100) / 100);
                                                LogUtil.addLineToSB(sb, "x轴方向倾角: ", result.getAngle_x());
                                                LogUtil.addLineToSB(sb, "t_y: ", Math.round(result.getT_y() * 100) / 100);
                                                LogUtil.addLineToSB(sb, "y轴方向倾角: ", result.getAngle_y());
                                                LogUtil.addLineToSB(sb, "z轴方向倾角: ", result.getAngle_z());
                                                LogUtil.addLineToSB(sb, "距离屏幕中心 x(px): ", Math.round((screenX - result.getCenter_x()) * 100) / 100);
                                                LogUtil.addLineToSB(sb, "距离屏幕中心 y(px): ", Math.round((screenY - result.getCenter_y()) * 100) / 100);


                                                writeAprilTagsStatus(result.id, result.getT_x(), result.getT_y(), (float) (screenX - result.getCenter_x()), (float) (screenY - result.getCenter_y()), ultrasonicHeight, pidControlIncTestX.pidRealize((float) (screenX - result.getCenter_x())), pidControlIncTestY.pidRealize((float) (screenY - result.getCenter_y())), result.getAngle_z());


                                                runOnUiThread(new Runnable() {
                                                    @Override
                                                    public void run() {
                                                        if (WriteFileUtil.isExternalStorageWritable()) {
                                                            String status = Environment.getExternalStorageState();
                                                            if (status.equals(Environment.MEDIA_MOUNTED)) {
                                                                File dir = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/droneplus/");
                                                                if (!dir.exists()) {
                                                                    dir.mkdir();
                                                                }
                                                                WriteFileUtil.putStringToExternalStorage(result.getAngle_x() + "\r\n", dir, "angle_x_tag.txt", true);
                                                                WriteFileUtil.putStringToExternalStorage(result.getAngle_y() + "\r\n", dir, "angle_y_tag.txt", true);
                                                            }
                                                        }
                                                    }
                                                });

                                                break;
                                        }

                                        setResultToText(sb.toString(), result.id);

                                        //                                        if (ultrasonicHeight >= 2.0) {

                                        //                                            if (cy < screenY / 5 * 2 || cy > screenY * 2 / 10 * 8 || cx < screenX / 5 * 2 || cx > screenX * 2 / 10 * 8) {
                                        //                                                // 第一象限
                                        //                                                if (ctx > 0 && cty < 0) {
                                        //                                                    cdx = cdx + rtdx;
                                        //                                                    cdy = cdy - rtdy;
                                        ////                                                    Log.i("dongdXdY3", "cdx : " + cdx + " cdy: " + cdy);
                                        //                                                }
                                        //                                                // 第二象限
                                        //                                                if (ctx < 0 && cty < 0) {
                                        //                                                    cdx = cdx - ltdx;
                                        //                                                    cdy = cdy - ltdy;
                                        ////                                                    Log.i("dongdXdY4", "cdx : " + cdx + " cdy: " + cdy);
                                        //                                                }
                                        //                                                // 第三象限
                                        //                                                if (ctx < 0 && cty > 0) {
                                        //                                                    cdx = cdx - rbdx;
                                        //                                                    cdy = cdy + rbdy;
                                        ////                                                    Log.i("dongdXdY1", "cdx : " + cdx + " cdy: " + cdy);
                                        //                                                }
                                        //                                                // 第四象限
                                        //                                                if (ctx > 0 && cty > 0) {
                                        //                                                    cdx = cdx + lbdx;
                                        //                                                    cdy = cdy + lbdy;
                                        ////                                                    Log.i("dongdXdY2", "cdx : " + cdx + " cdy: " + cdy);
                                        //                                                }
                                        //                                            }
                                        //
                                        //                                        } else
                                        if (ultrasonicHeight < 2.5 && ultrasonicHeight >= 1.5) {
                                            if (cy < screenY / 5 * 2.5 || cy > screenY * 2 / 10 * 7.5 || cx < screenX / 5 * 2.5 || cx > screenX * 2 / 10 * 7.5) {
                                                // 第一象限
                                                if (ctx > 0 && cty < 0) {

                                                    //                                                    if (Math.abs(cdx) < 10000) {
                                                    //                                                        cdx = cdx - ltdx;
                                                    //                                                    } else {
                                                    //                                                        cdx = -10000;
                                                    //                                                    }
                                                    //
                                                    //                                                    if (Math.abs(cdy) < 10000) {
                                                    //                                                        cdy = cdy + ltdy;
                                                    //                                                    } else {
                                                    //                                                        cdy = 10000;
                                                    //                                                    }

                                                    cdx = cdx - lbdx;
                                                    cdy = cdy + lbdy;

                                                }
                                                // 第二象限
                                                if (ctx < 0 && cty < 0) {
                                                    //                                                    if (Math.abs(cdx) < 10000) {
                                                    //                                                        cdx = cdx + ltdx;
                                                    //                                                    } else {
                                                    //                                                        cdx = 10000;
                                                    //                                                    }
                                                    //
                                                    //                                                    if (Math.abs(cdy) < 10000) {
                                                    //                                                        cdy = cdy + ltdy;
                                                    //                                                    } else {
                                                    //                                                        cdy = 10000;
                                                    //                                                    }
                                                    cdx = cdx + rbdx;
                                                    cdy = cdy + rbdy;

                                                }
                                                // 第三象限
                                                if (ctx < 0 && cty > 0) {
                                                    //                                                    if (Math.abs(cdx) < 10000) {
                                                    //                                                        cdx = cdx + ltdx;
                                                    //                                                    } else {
                                                    //                                                        cdx = 10000;
                                                    //                                                    }
                                                    //
                                                    //                                                    if (Math.abs(cdy) < 10000) {
                                                    //                                                        cdy = cdy - ltdy;
                                                    //                                                    } else {
                                                    //                                                        cdy = -10000;
                                                    //                                                    }
                                                    cdx = cdx + rtdx;
                                                    cdy = cdy - rtdy;

                                                }
                                                // 第四象限
                                                if (ctx > 0 && cty > 0) {
                                                    //                                                    if (Math.abs(cdx) < 10000) {
                                                    //                                                        cdx = cdx - ltdx;
                                                    //                                                    } else {
                                                    //                                                        cdx = -10000;
                                                    //                                                    }
                                                    //
                                                    //                                                    if (Math.abs(cdy) < 10000) {
                                                    //                                                        cdy = cdy - ltdy;
                                                    //                                                    } else {
                                                    //                                                        cdy = -10000;
                                                    //                                                    }
                                                    cdx = cdx - ltdx;
                                                    cdy = cdy - ltdy;

                                                }
                                            }
                                        } else if (ultrasonicHeight < 1.5) {
                                            if (cy < screenY / 5 * 3 || cy > screenY * 2 / 10 * 7 || cx < screenX / 5 * 3 || cx > screenX * 2 / 10 * 7) {
                                                Log.i("dong3ge", "run: ");

                                                // 第一象限
                                                if (ctx > 0 && cty < 0) {

                                                    // 左下标签在第二、三象限用rb
                                                    //                                                    if ((lbx < screenX && lby < screenY) || (lbx < screenX && lby > screenY)) {
                                                    //                                                        cdx = cdx - lbdx;
                                                    //                                                        cdy = cdy + lbdy;
                                                    //                                                    } else {
                                                    //                                                        cdx = cdx - rbdx;
                                                    //                                                        cdy = cdy + rbdy;
                                                    //                                                    }

                                                    //                                                    if (Math.abs(cdx) < 10000) {
                                                    //                                                        cdx = cdx - ltdx;
                                                    //                                                    } else {
                                                    //                                                        cdx = -10000;
                                                    //                                                    }
                                                    //
                                                    //                                                    if (Math.abs(cdy) < 10000) {
                                                    //                                                        cdy = cdy + ltdy;
                                                    //                                                    } else {
                                                    //                                                        cdy = 10000;
                                                    //                                                    }

                                                    cdx = cdx - lbdx;
                                                    cdy = cdy + lbdy;
                                                    Log.i("dngdXdY1", "cdx : " + cdx + " cdy: " + cdy);
                                                }
                                                // 第二象限
                                                if (ctx < 0 && cty < 0) {

                                                    // 右下标签在第一象限用lb
                                                    //                                                    if (rbx > screenX && rby < screenY) {
                                                    //
                                                    //                                                        cdx = cdx + rbdx;
                                                    //                                                        cdy = cdy + rbdy;
                                                    //                                                    } else {
                                                    //                                                        cdx = cdx + lbdx;
                                                    //                                                        cdy = cdy + lbdy;
                                                    //
                                                    //                                                    }

                                                    //                                                    if (Math.abs(cdx) < 10000) {
                                                    //                                                        cdx = cdx + ltdx;
                                                    //                                                    } else {
                                                    //                                                        cdx = 10000;
                                                    //                                                    }
                                                    //
                                                    //                                                    if (Math.abs(cdy) < 10000) {
                                                    //                                                        cdy = cdy + ltdy;
                                                    //                                                    } else {
                                                    //                                                        cdy = 10000;
                                                    //                                                    }

                                                    cdx = cdx + rbdx;
                                                    cdy = cdy + rbdy;
                                                    Log.i("dngdXdY2", "cdx : " + cdx + " cdy: " + cdy);
                                                }
                                                // 第三象限
                                                if (ctx < 0 && cty > 0) {

                                                    //右上标签在第四象限用lt
                                                    //                                                    if (rtx > screenX && rty > screenY) {
                                                    //                                                        cdx = cdx + rtdx;
                                                    //                                                        cdy = cdy - rtdy;
                                                    //                                                    } else {
                                                    //                                                        cdx = cdx + ltdx;
                                                    //                                                        cdy = cdy - ltdy;
                                                    //                                                    }

                                                    //                                                    if (Math.abs(cdx) < 10000) {
                                                    //                                                        cdx = cdx + ltdx;
                                                    //                                                    } else {
                                                    //                                                        cdx = 10000;
                                                    //                                                    }
                                                    //
                                                    //                                                    if (Math.abs(cdy) < 10000) {
                                                    //                                                        cdy = cdy - ltdy;
                                                    //                                                    } else {
                                                    //                                                        cdy = -10000;
                                                    //                                                    }

                                                    cdx = cdx + rtdx;
                                                    cdy = cdy - rtdy;
                                                    Log.i("dngdXdY3", "cdx : " + cdx + " cdy: " + cdy);
                                                }
                                                // 第四象限
                                                if (ctx > 0 && cty > 0) {

                                                    //左上标签在第三象限用rt
                                                    //                                                    if (ltx < screenX && lty > screenY) {
                                                    //                                                        cdx = cdx - ltdx;
                                                    //                                                        cdy = cdy - ltdy;
                                                    //                                                    } else {
                                                    //                                                        cdx = cdx - rtdx;
                                                    //                                                        cdy = cdy - rtdy;
                                                    //                                                    }

                                                    if (Math.abs(cdx) < 10000) {
                                                        cdx = cdx - ltdx;
                                                    } else {
                                                        cdx = -10000;
                                                    }

                                                    if (Math.abs(cdy) < 10000) {
                                                        cdy = cdy - ltdy;
                                                    } else {
                                                        cdy = -10000;
                                                    }

                                                    //                                                    cdx = cdx - ltdx;
                                                    //                                                    cdy = cdy - ltdy;
                                                    Log.i("dngdXdY4", "cdx : " + cdx + " cdy: " + cdy);
                                                }
                                            }
                                        }


                                        if (notfirstRec0) {
                                            // 无人机降落

                                            // 保留最后一次的误差
                                            last_t_x = t_x;
                                            last_t_y = t_y;
                                            last_tagCenterX = cdx;
                                            last_tagCenterY = cdy;

                                            // X轴方向，方框中心与屏幕中心的距离差
                                            //                                            dX = (float) (screenX - tagCenterX);
                                            //                                            dY = (float) (screenY - tagCenterY);
                                            dX = (float) cdx;
                                            dY = (float) cdy;

                                            //                                            Log.i("dongdXdY0", "dX : " + (screenX - tagCenterX) + " dY: " + (screenY - tagCenterY));
                                            //                                            Log.i("dongdXdY0", "cdX : " + dX + " cdY: " + dY);

                                            //                                            writeAprilTagsStatus(12, 12, 12, (float) (screenX - tagCenterX), (float) (screenY - tagCenterY), 0,0,0,0);
                                            //                                            writeAprilTagsStatus(13, 13, 13, dX, dY, 0,0,0,0);


                                            controlValueIncTurn = pidControlIncTestTurn.pidRealize((float) angle_z);

                                            //                                        Log.i("dongdXdYangle", "controlValueIncTurn : " + controlValueIncTurn);

                                            // 增量式PID算法，计算x轴方向的控制量

                                            if (Math.abs(dX) >= errXprecise) { // 距离差>=30像素时，需要调整水平位置，计算得到控制量
                                                controlValueIncX = pidControlIncTestX.pidRealize(dX);
                                            }
                                            if (Math.abs(dY) >= errYprecise) {
                                                controlValueIncY = pidControlIncTestY.pidRealize(dY);
                                            }

                                            Log.i("dongnotfindmark", "run: controlValueIncX: " + controlValueIncX + " controlValueIncY: " + controlValueIncY);

                                            //                                            if (Math.abs(t_x) >= 80) {
                                            //                                                controlValueIncX = controlValueIncX / 10;
                                            //                                            }
                                            //
                                            //                                            if (Math.abs(t_y) >= 40) {
                                            //                                                controlValueIncY = controlValueIncY / 10;
                                            //                                            }

                                            //                                        Log.i("dongdXdYcontrolIncXY", "controlValueIncX : " + controlValueIncX + " controlValueIncY: " + controlValueIncY);

                                            // 将数据写入文件，包括每次识别后：停机坪框的中心与屏幕中心在x轴和y轴的距离差、无人机高度、x方向和y方向的控制量、当前时间
                                            //                                        runOnUiThread(new Runnable() {
                                            //                                            @Override
                                            //                                            public void run() {
                                            //                                                if (WriteFileUtil.isExternalStorageWritable()) {
                                            //                                                    String status = Environment.getExternalStorageState();
                                            //                                                    if (status.equals(Environment.MEDIA_MOUNTED)) {
                                            //                                                        File dir = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/droneplus/");
                                            //                                                        if (!dir.exists()) {
                                            //                                                            dir.mkdir();
                                            //                                                        }
                                            //                                                        WriteFileUtil.putStringToExternalStorage(t_x + "\r\n", dir, "t_x_tag.txt", true);
                                            //                                                        WriteFileUtil.putStringToExternalStorage(t_y + "\r\n", dir, "t_y_tag.txt", true);
                                            //                                                        WriteFileUtil.putStringToExternalStorage(dX + "\r\n", dir, "dx_tag.txt", true);
                                            //                                                        WriteFileUtil.putStringToExternalStorage(dY + "\r\n", dir, "dy_tag.txt", true);
                                            //                                                        WriteFileUtil.putStringToExternalStorage(ultrasonicHeight + "\r\n", dir, "height_tag.txt", true);
                                            //                                                        WriteFileUtil.putStringToExternalStorage(controlValueIncX + "\r\n", dir, "PIDx_tag.txt", true);
                                            //                                                        WriteFileUtil.putStringToExternalStorage(controlValueIncY + "\r\n", dir, "PIDy_tag.txt", true);
                                            //                                                        //                                        WriteFileUtil.putStringToExternalStorage(controlValueIncTurn+"\r\n", dir, "PID_turn.txt", true);
                                            //                                                        WriteFileUtil.putStringToExternalStorage(currentTime() + "\r\n", dir, "time_tag.txt", true);
                                            //                                                        WriteFileUtil.putStringToExternalStorage(angle_z + "\r\n", dir, "angle_tag.txt", true);
                                            //                                                    }
                                            //                                                }
                                            //                                            }
                                            //                                        });

                                            if (Math.abs(angle_z) > 1) {
                                                leftRight = 0;
                                                frontBack = 0;
                                                upDown = 0;
                                                if (angle_z > 2 && angle_z <= 80) {
                                                    turnLeftRight = (-1) * Math.abs(controlValueIncTurn);
                                                    if (mFlightController != null) { // 向右转
                                                        runOnUiThread(new Runnable() {
                                                            @Override
                                                            public void run() {
                                                                angleTv.setText(controlValueIncTurn + "");
                                                                if (WriteFileUtil.isExternalStorageWritable()) {
                                                                    String status = Environment.getExternalStorageState();
                                                                    if (status.equals(Environment.MEDIA_MOUNTED)) {
                                                                        File dir = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/droneplus/");
                                                                        if (!dir.exists()) {
                                                                            dir.mkdir();
                                                                        }
                                                                        WriteFileUtil.putStringToExternalStorage(controlValueIncTurn + "\r\n", dir, "PID_turn_tag.txt", true);
                                                                    }
                                                                }
                                                            }
                                                        });
                                                        flyControl(0, 0, Math.abs(controlValueIncTurn), 0);
                                                        //                                            sendVirtualStickDataTask = new SendVirtualStickDataTask();
                                                        //                                            sendVirtualStickDataTimer = new Timer();
                                                        //                                            sendVirtualStickDataTimer.schedule(sendVirtualStickDataTask, 0, 200);
                                                    }
                                                }
                                                if (angle_z < -2 && angle_z >= -80) {
                                                    turnLeftRight = Math.abs(controlValueIncTurn);
                                                    if (mFlightController != null) { // 向左转
                                                        runOnUiThread(new Runnable() {
                                                            @Override
                                                            public void run() {
                                                                angleTv.setText(controlValueIncTurn + "");
                                                                if (WriteFileUtil.isExternalStorageWritable()) {
                                                                    String status = Environment.getExternalStorageState();
                                                                    if (status.equals(Environment.MEDIA_MOUNTED)) {
                                                                        File dir = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/droneplus/");
                                                                        if (!dir.exists()) {
                                                                            dir.mkdir();
                                                                        }
                                                                        WriteFileUtil.putStringToExternalStorage(controlValueIncTurn + "\r\n", dir, "PID_turn_tag.txt", true);
                                                                    }
                                                                }
                                                            }
                                                        });
                                                        flyControl(0, 0, (-1) * Math.abs(controlValueIncTurn), 0);
                                                        //                                            sendVirtualStickDataTask = new SendVirtualStickDataTask();
                                                        //                                            sendVirtualStickDataTimer = new Timer();
                                                        //                                            sendVirtualStickDataTimer.schedule(sendVirtualStickDataTask, 0, 200);
                                                    }
                                                }
                                            }

                                            //                                            if (ultrasonicHeight <= 3.2 && ultrasonicHeight > 2.0) { // 3m-2.0m调整一次
                                            if (ultrasonicHeight > 2.0) { // 3m-2.0m调整一次
                                                // 第一象限
                                                if (t_x < 0 && t_y > 0) {
                                                    if ((Math.abs(dX) >= errXprecise || Math.abs(dY) >= errYprecise) && !tagfirstLanding) {
                                                        adjustTimes = 0;
                                                        flyControl((-1) * Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, -0.2f);
                                                    }
                                                }
                                                // 第二象限
                                                if (t_x > 0 && t_y > 0) {
                                                    if ((Math.abs(dX) >= errXprecise || Math.abs(dY) >= errYprecise) && !tagfirstLanding) {
                                                        adjustTimes = 0;
                                                        flyControl(Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, -0.2f);
                                                    }
                                                }
                                                // 第三象限
                                                if (t_x > 0 && t_y < 0) {
                                                    if ((Math.abs(dX) >= errXprecise || Math.abs(dY) >= errYprecise) && !tagfirstLanding) {
                                                        adjustTimes = 0;
                                                        flyControl(Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, -0.2f);
                                                    }
                                                }
                                                // 第四象限
                                                if (t_x < 0 && t_y < 0) {
                                                    if ((Math.abs(dX) >= errXprecise || Math.abs(dY) >= errYprecise) && !tagfirstLanding) {
                                                        adjustTimes = 0;
                                                        flyControl((-1) * Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, -0.2f);
                                                    }
                                                }
                                            }

                                            if (ultrasonicHeight <= 2.0 && ultrasonicHeight > 1.0) { // 2.0m调整一次
                                                // 第一象限

                                                if (t_x < 0 && t_y > 0) {

                                                    if ((Math.abs(t_x) <= 18.0 && Math.abs(t_y) <= 17.0) && !tagsecondLanding) {
                                                        flyControl((-1) * Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, -0.08f);
                                                    } else if ((Math.abs(t_x) > 18.0 || Math.abs(t_y) > 17.0) && !tagsecondLanding) {
                                                        adjustTimes = 0;
                                                        flyControl((-1) * Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, -0.03f);
                                                    }

                                                    if ((Math.abs(t_x) < 17.0 && Math.abs(t_y) < 16.0) && !tagsecondLanding) {
                                                        adjustTimes++;

                                                        if (adjustTimes >= 2) {
                                                            tagsecondLanding = true;
                                                            adjustTimes = 0;
                                                        }
                                                    }

                                                    if (tagsecondLanding) {
                                                        if (ultrasonicHeight > 0) {
                                                            flyControl(0, 0, 0, -0.2f);
                                                        }
                                                    }
                                                }
                                                // 第二象限
                                                if (t_x > 0 && t_y > 0) {
                                                    if ((Math.abs(t_x) <= 18.0 && Math.abs(t_y) <= 17.0) && !tagsecondLanding) {
                                                        flyControl(Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, -0.08f);
                                                    } else if ((Math.abs(t_x) > 18.0 || Math.abs(t_y) > 17.0) && !tagsecondLanding) {
                                                        adjustTimes = 0;
                                                        flyControl(Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, -0.03f);
                                                    }
                                                    if ((Math.abs(t_x) < 17.0 && Math.abs(t_y) < 16.0) && !tagsecondLanding) {
                                                        adjustTimes++;
                                                        if (adjustTimes >= 2) {
                                                            tagsecondLanding = true;
                                                            adjustTimes = 0;
                                                        }
                                                    }
                                                    if (tagsecondLanding) {
                                                        if (ultrasonicHeight > 0) {
                                                            flyControl(0, 0, 0, -0.2f);
                                                        }
                                                    }
                                                }
                                                // 第三象限
                                                if (t_x > 0 && t_y < 0) {
                                                    if ((Math.abs(t_x) <= 18.0 && Math.abs(t_y) <= 17.0) && !tagsecondLanding) {
                                                        flyControl(Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, -0.08f);
                                                    } else if ((Math.abs(t_x) > 18.0 || Math.abs(t_y) > 17.0) && !tagsecondLanding) {
                                                        adjustTimes = 0;
                                                        flyControl(Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, -0.03f);
                                                    }
                                                    if ((Math.abs(t_x) < 17.0 && Math.abs(t_y) < 16.0) && !tagsecondLanding) {
                                                        adjustTimes++;
                                                        if (adjustTimes >= 2) {
                                                            tagsecondLanding = true;
                                                            adjustTimes = 0;
                                                        }
                                                    }
                                                    if (tagsecondLanding) {
                                                        if (ultrasonicHeight > 0) {
                                                            flyControl(0, 0, 0, -0.2f);
                                                        }
                                                    }
                                                }
                                                // 第四象限
                                                if (t_x < 0 && t_y < 0) {
                                                    if ((Math.abs(t_x) <= 18.0 && Math.abs(t_y) <= 17.0) && !tagsecondLanding) {
                                                        flyControl((-1) * Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, -0.08f);
                                                    } else if ((Math.abs(t_x) > 18.0 || Math.abs(t_y) > 17.0) && !tagsecondLanding) {
                                                        adjustTimes = 0;
                                                        flyControl((-1) * Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, -0.03f);
                                                    }
                                                    if ((Math.abs(t_x) < 17.0 && Math.abs(t_y) < 16.0) && !tagsecondLanding) {
                                                        adjustTimes++;
                                                        if (adjustTimes >= 2) {
                                                            tagsecondLanding = true;
                                                            adjustTimes = 0;
                                                        }
                                                    }
                                                    if (tagsecondLanding) {
                                                        if (ultrasonicHeight > 0) {
                                                            flyControl(0, 0, 0, -0.2f);
                                                        }
                                                    }
                                                }
                                            }

                                            if (ultrasonicHeight <= 1.0 && ultrasonicHeight > 0.5) { // 1.0m调整一次
                                                // 第一象限
                                                // 左后
                                                if (t_x < 0 && t_y > 0) {
                                                    if ((Math.abs(t_x) <= 15.0 && Math.abs(t_y) <= 14.0) && !tagthirdLanding) {
                                                        flyControl((-1) * Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, -0.05f);
                                                    } else if ((Math.abs(t_x) > 15.0 || Math.abs(t_y) > 14.0) && !tagthirdLanding) {
                                                        adjustTimes = 0;
                                                        flyControl((-1) * Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, 0);
                                                    }
                                                    if ((Math.abs(t_x) < 14.0 && Math.abs(t_y) < 13.0) && !tagthirdLanding) {
                                                        adjustTimes++;
                                                        Log.i("dongtagthirdLanding", "run: adjustTimes" + adjustTimes);
                                                        if (adjustTimes >= 2) {
                                                            tagthirdLanding = true;
                                                            adjustTimes = 0;
                                                        }
                                                    }
                                                    if (tagthirdLanding) {
                                                        Log.i("dongtagthirdLanding", "run: " + tagthirdLanding);
                                                        if (ultrasonicHeight >= 0) {
                                                            flyControl(0, 0, 0, -0.5f);
                                                        }
                                                    }
                                                }
                                                // 第二象限
                                                // 右后
                                                if (t_x > 0 && t_y > 0) {
                                                    if ((Math.abs(t_x) <= 15.0 && Math.abs(t_y) <= 14.0) && !tagthirdLanding) {
                                                        flyControl(Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, -0.05f);
                                                    } else if ((Math.abs(t_x) > 15.0 || Math.abs(t_y) > 14.0) && !tagthirdLanding) {
                                                        adjustTimes = 0;
                                                        flyControl(Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, 0);
                                                    }
                                                    if ((Math.abs(t_x) < 14.0 && Math.abs(t_y) < 13.0) && !tagthirdLanding) {
                                                        adjustTimes++;
                                                        if (adjustTimes >= 2) {
                                                            tagthirdLanding = true;
                                                            adjustTimes = 0;
                                                        }
                                                    }
                                                    if (tagthirdLanding) {
                                                        if (ultrasonicHeight >= 0) {
                                                            flyControl(0, 0, 0, -0.5f);
                                                        }
                                                    }
                                                }
                                                // 第三象限
                                                // 右前
                                                if (t_x > 0 && t_y < 0) {
                                                    if ((Math.abs(t_x) <= 15.0 && Math.abs(t_y) <= 14.0) && !tagthirdLanding) {
                                                        flyControl(Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, -0.05f);
                                                    } else if ((Math.abs(t_x) > 15.0 || Math.abs(t_y) > 14.0) && !tagthirdLanding) {
                                                        adjustTimes = 0;
                                                        flyControl(Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, 0);
                                                    }
                                                    if ((Math.abs(t_x) < 14.0 && Math.abs(t_y) < 13.0) && !tagthirdLanding) {
                                                        adjustTimes++;
                                                        if (adjustTimes >= 2) {
                                                            tagthirdLanding = true;
                                                            adjustTimes = 0;
                                                        }
                                                    }
                                                    if (tagthirdLanding) {
                                                        if (ultrasonicHeight >= 0) {
                                                            flyControl(0, 0, 0, -0.5f);
                                                        }
                                                    }
                                                }
                                                // 第四象限
                                                // 左前
                                                if (t_x < 0 && t_y < 0) {
                                                    if ((Math.abs(t_x) <= 15.0 && Math.abs(t_y) <= 14.0) && !tagthirdLanding) {
                                                        flyControl((-1) * Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, -0.05f);
                                                    } else if ((Math.abs(t_x) > 15.0 || Math.abs(t_y) > 14.0) && !tagthirdLanding) {
                                                        adjustTimes = 0;
                                                        flyControl((-1) * Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, 0);
                                                    }
                                                    if ((Math.abs(t_x) < 14.0 && Math.abs(t_y) < 13.0) && !tagthirdLanding) {
                                                        adjustTimes++;
                                                        if (adjustTimes >= 2) {
                                                            tagthirdLanding = true;
                                                            adjustTimes = 0;
                                                        }
                                                    }
                                                    if (tagthirdLanding) {
                                                        if (ultrasonicHeight >= 0) {
                                                            flyControl(0, 0, 0, -0.5f);
                                                        }
                                                    }
                                                }
                                            }

                                            if (ultrasonicHeight <= 0.5) { // 0.5m调整一次
                                                // 第一象限
                                                if (t_x < 0 && t_y > 0) {
                                                    if ((Math.abs(t_x) > 11.0 || Math.abs(t_y) > 10.0) && !tagforthLanding) {
                                                        adjustTimes = 0;
                                                        flyControl((-1) * Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, 0);
                                                    }
                                                    if ((Math.abs(t_x) < 11.0 && Math.abs(t_y) < 10.0) && !tagthirdLanding) {
                                                        adjustTimes++;
                                                        if (adjustTimes >= 1) {
                                                            tagforthLanding = true;
                                                            adjustTimes = 0;
                                                        }
                                                    }
                                                    if (tagforthLanding) {
                                                        if (ultrasonicHeight >= 0) {
                                                            flyControl(0, 0, 0, -0.5f);
                                                        }
                                                    }
                                                }
                                                // 第二象限
                                                if (t_x > 0 && t_y > 0) {
                                                    if ((Math.abs(t_x) > 11.0 || Math.abs(t_y) > 10.0) && !tagforthLanding) {
                                                        adjustTimes = 0;
                                                        flyControl(Math.abs(controlValueIncX), (-1) * Math.abs(controlValueIncY), 0, 0);
                                                    }
                                                    if ((Math.abs(t_x) < 11.0 && Math.abs(t_y) < 10.0) && !tagthirdLanding) {
                                                        adjustTimes++;
                                                        if (adjustTimes >= 1) {
                                                            tagforthLanding = true;
                                                            adjustTimes = 0;
                                                        }
                                                    }
                                                    if (tagforthLanding) {
                                                        if (ultrasonicHeight >= 0) {
                                                            flyControl(0, 0, 0, -0.5f);
                                                        }
                                                    }
                                                }
                                                // 第三象限
                                                if (t_x > 0 && t_y < 0) {
                                                    if ((Math.abs(t_x) > 11.0 || Math.abs(t_y) > 10.0) && !tagforthLanding) {
                                                        adjustTimes = 0;
                                                        flyControl(Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, 0);
                                                    }
                                                    if ((Math.abs(t_x) < 11.0 && Math.abs(t_y) < 10.0) && !tagthirdLanding) {
                                                        adjustTimes++;
                                                        if (adjustTimes >= 1) {
                                                            tagforthLanding = true;
                                                            adjustTimes = 0;
                                                        }
                                                    }
                                                    if (tagforthLanding) {
                                                        if (ultrasonicHeight >= 0) {
                                                            flyControl(0, 0, 0, -0.5f);
                                                        }
                                                    }
                                                }
                                                // 第四象限
                                                if (t_x < 0 && t_y < 0) {
                                                    if ((Math.abs(t_x) > 11.0 || Math.abs(t_y) > 10.0) && !tagforthLanding) {
                                                        adjustTimes = 0;
                                                        flyControl((-1) * Math.abs(controlValueIncX), Math.abs(controlValueIncY), 0, 0);
                                                    }
                                                    if ((Math.abs(t_x) < 11.0 && Math.abs(t_y) < 10.0) && !tagthirdLanding) {
                                                        adjustTimes++;
                                                        if (adjustTimes >= 1) {
                                                            tagforthLanding = true;
                                                            adjustTimes = 0;
                                                        }
                                                    }
                                                    if (tagforthLanding) {
                                                        if (ultrasonicHeight >= 0) {
                                                            flyControl(0, 0, 0, -0.5f);
                                                        }
                                                    }
                                                }
                                            }

                                        } else {

                                        }
                                    }
                                }

                            }

                        }

                    });

                } else {
                    flyControl(0, 0, 0, -0.3f);
                    BaseProduct product = DJISDKManager.getInstance().getProduct();
                    if (product != null && product.getModel() != null) {
                        switch (product.getModel()) {
                            case MAVIC_2:
                            case MAVIC_2_PRO:
                            case MAVIC_2_ZOOM:
                                Log.i("dongstartLanding", "run: MAVIC_2_ZOOM");
                                mFlightController.startLanding(new CommonCallbacks.CompletionCallback() {
                                    @Override
                                    public void onResult(DJIError djiError) {
                                        Log.i("dongstartLanding", "djiError: ");
                                    }
                                });
                                break;
                            case PHANTOM_4:
                            case PHANTOM_4_PRO: // p4p
                                Log.i("dongstartLanding", "run: PHANTOM_4_PRO");
                                flyControl(0, 0, 0, -0.3f);
                                break;
                            default:
                                Log.i("dongstartLanding", "run: default");
                                flyControl(0, 0, 0, -0.3f);
                                break;
                        }
                    }
                }

                // 若无人机螺旋桨的电机已停止转动
/*                    if (!mFlightController.getState().areMotorsOn()) {
                        runOnUiThread(new Runnable() {
                            @Override
                            public void run() {
                                setResultToToast("已安全降落!");
                                tagFlag = false;
                                isDetection = false;
                                tagThread.interrupt();
                                detectIv.setImageResource(R.mipmap.detect_close_u);
                                // 关闭虚拟摇杆
                                if (mFlightController != null) {
                                    mFlightController.setVirtualStickModeEnabled(false, new CommonCallbacks.CompletionCallback() {
                                        @Override
                                        public void onResult(DJIError djiError) {
                                            if (djiError != null) {
                                                setResultToToast(djiError.getDescription());
                                            } else {
                                                //                                                setResultToToast("虚拟摇杆关闭");
                                            }
                                        }
                                    });
                                }
                            }
                        });
                    }*/
            }

            //            tagHandler.postDelayed(this, 200);
            //            Log.i("tagHandler == 200", "执行完tagHandler时间：" + System.currentTimeMillis() + "ms");
        }
    };

    /**
     * 虚拟摇杆功能，可通过程序控制无人机的前、后、左、右、上升、下降的飞行动作
     *
     * @param leftRight     正数为右，负数为左
     * @param frontBack     正数为前，负数为后
     * @param turnLeftRight
     * @param upDown        正数为上升，负数为下降
     */
    private class SendVirtualStickDataTask extends TimerTask {

        @Override
        public void run() {
            mFlightController.sendVirtualStickFlightControlData(new FlightControlData(leftRight, frontBack, turnLeftRight, upDown), new CommonCallbacks.CompletionCallback() {
                @Override
                public void onResult(DJIError djiError) {

                }
            });
        }
    }


    /**
     * 虚拟摇杆功能，可通过程序控制无人机的前、后、左、右、上升、下降的飞行动作
     *
     * @param leftRight     正数为右，负数为左
     * @param frontBack     正数为前，负数为后
     * @param turnLeftRight
     * @param upDown        正数为上升，负数为下降
     */
    private void flyControl(float leftRight, float frontBack, float turnLeftRight, float upDown) {
        if (mFlightController == null) {
            BaseProduct product = DemoApplication.getProductInstance();
            if (product == null || !product.isConnected()) {
                setResultToToast("未连接到无人机！");
                missionControl = null;
            } else {
                missionControl = MissionControl.getInstance(); // 任务控制器实例
                if (product instanceof Aircraft) {
                    Aircraft aircraft = (Aircraft) DJISDKManager.getInstance().getProduct();
                    mFlightController = aircraft.getFlightController();
                }
            }
        }

        mFlightController.sendVirtualStickFlightControlData(new FlightControlData(leftRight, frontBack, turnLeftRight, upDown), new CommonCallbacks.CompletionCallback() {
            @Override
            public void onResult(DJIError djiError) {

            }
        });
    }

    private String currentTime() {
        SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss");
        Date curDate = new Date(System.currentTimeMillis());

        return sdf.format(curDate);

    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        //        loginAccount();
        super.onCreate(savedInstanceState);
        // When the compile and target version is higher than 22, please request the
        // following permissions at runtime to ensure the
        // SDK work well.
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.VIBRATE, Manifest.permission.INTERNET, Manifest.permission.ACCESS_WIFI_STATE, Manifest.permission.WAKE_LOCK, Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_NETWORK_STATE, Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.CHANGE_WIFI_STATE, Manifest.permission.MOUNT_UNMOUNT_FILESYSTEMS, Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.SYSTEM_ALERT_WINDOW, Manifest.permission.READ_PHONE_STATE,}, 1);
        }
        setContentView(R.layout.activity_main);
        initUi(savedInstanceState);
    }

    private void initUi(Bundle savedInstanceState) {

        // 获取屏幕大小
        WindowManager manager = (WindowManager) this.getSystemService(Context.WINDOW_SERVICE);
        Display display = manager.getDefaultDisplay();
        Point point = new Point();
        if (Build.VERSION.SDK_INT < 17) {
            display.getSize(point);
        } else {
            display.getRealSize(point);
        }
        width = point.x;
        height = point.y;

        errX = (float) (width * 0.015); // width = 2560时，errX = 38.4
        errY = (float) (height * 0.025); // height = 1600时，errY = 40

        errXprecise = (float) (width * 0.012); // width = 2560时，errX = 30.72
        errYprecise = (float) (height * 0.02); // height = 1600时，errY = 32

        screenX = width / 2;
        screenY = height / 2;

        // 地图视频切换
        mapContainer = (RelativeLayout) findViewById(R.id.map_container);
        dcontainer = (RelativeLayout) findViewById(R.id.vedio_container);
        cover = new RelativeLayout(this);

        mView = LayoutInflater.from(this).inflate(R.layout.mapview, null);
        vview = LayoutInflater.from(this).inflate(R.layout.vidview, null);
        fpvWidget = vview.findViewById(R.id.video);
        mapView = mView.findViewById(R.id.map);
        mapView.onCreate(savedInstanceState);
        initMapView(); // 初始化地图

        mapContainer.addView(mView, new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
        mapContainer.addView(cover, new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
        dcontainer.addView(vview, new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
        cover.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                if (!isMap) {
                    uiSettings = aMap.getUiSettings();
                    uiSettings.setZoomControlsEnabled(true);
                    uiSettings.setZoomInByScreenCenter(true);
                    uiSettings.setAllGesturesEnabled(true);
                    uiSettings.setCompassEnabled(true);
                    mapView.setClickable(true);

                    mapContainer.removeAllViews();
                    dcontainer.removeAllViews();
                    dcontainer.addView(mView, new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
                    mapContainer.addView(fpvWidget);
                    mapContainer.addView(cover);
                    isMap = true;
                } else {
                    uiSettings = aMap.getUiSettings();
                    uiSettings.setZoomControlsEnabled(false);
                    uiSettings.setZoomInByScreenCenter(true);
                    uiSettings.setAllGesturesEnabled(true);
                    uiSettings.setCompassEnabled(true);
                    mapView.setClickable(true);

                    mapContainer.removeAllViews();
                    dcontainer.removeAllViews();
                    dcontainer.addView(vview, new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
                    mapContainer.addView(mapView);
                    mapContainer.addView(cover);
                    isMap = false;
                }
            }
        });

        // 三秒后地图拉到定位点中心位置
        Timer t = new Timer();
        t.schedule(new TimerTask() {
            @Override
            public void run() {
                updateDroneState();
                cameraUpdate();
            }
        }, 3000);

        pidControlIncTestX = new PIDControlIncTest();
        pidControlIncTestX.initPID(0.0009f, 0.00002f, 0.00001f);
        pidControlIncTestY = new PIDControlIncTest();
        pidControlIncTestY.initPID(0.0009f, 0.00002f, 0.00001f);
        pidControlIncTestTurn = new PIDControlIncTest();
        pidControlIncTestTurn.initPID(0.55f, 0f, 0f);

        //apriltags详情 抽屉
        mPushDrawerIb = (ImageButton) findViewById(R.id.tracking_drawer_control_ib);
        mPushInfoSd = (SlidingDrawer) findViewById(R.id.tracking_drawer_sd);
        ltPushInfoTv = (TextView) findViewById(R.id.lt_tracking_push_tv);
        lbPushInfoTv = (TextView) findViewById(R.id.lb_tracking_push_tv);
        rtPushInfoTv = (TextView) findViewById(R.id.rt_tracking_push_tv);
        rbPushInfoTv = (TextView) findViewById(R.id.rb_tracking_push_tv);
        cPushInfoTv = (TextView) findViewById(R.id.c_tracking_push_tv);

        videostreamPreviewSf = (SurfaceView) findViewById(R.id.livestream_preview_sf);
        videostreamPreviewSf.setClickable(true);
        videostreamPreviewSf.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                float rate = VideoFeeder.getInstance().getTranscodingDataRate();
                Toast.makeText(MainActivity.this, "current rate:" + rate + "Mbps", Toast.LENGTH_LONG);
                if (rate < 10) {
                    VideoFeeder.getInstance().setTranscodingDataRate(10.0f);
                    Toast.makeText(MainActivity.this, "set rate to 10Mbps", Toast.LENGTH_LONG);
                } else {
                    VideoFeeder.getInstance().setTranscodingDataRate(3.0f);
                    Toast.makeText(MainActivity.this, "set rate to 3Mbps", Toast.LENGTH_LONG);
                }
            }
        });

        landingIv = (ImageView) findViewById(R.id.landing_iv);
        detectIv = (ImageView) findViewById(R.id.detect_button);
        checkWaypointIv = (ImageView) findViewById(R.id.check_waypoint_iv);
        startIv = (ImageView) findViewById(R.id.start);
        disableSimulatorIv = (ImageView) findViewById(R.id.simulator_stop_iv);

        ultrasonicTv = (TextView) findViewById(R.id.ultrasonic_height);

        yawTv = (TextView) findViewById(R.id.drone_yaw_tv);
        pitchTv = (TextView) findViewById(R.id.drone_pitch_tv);
        angleTv = (TextView) findViewById(R.id.angle_tv_1);

        turnBtn = (Button) findViewById(R.id.turn_btn);

        landingIv.setOnTouchListener(this);
        detectIv.setOnTouchListener(this);
        checkWaypointIv.setOnTouchListener(this);
        startIv.setOnTouchListener(this);
        disableSimulatorIv.setOnClickListener(this);

        turnBtn.setOnClickListener(this);

        mPushDrawerIb.setOnClickListener(this);

        // 注册无人机监听广播
        // TODO initFlightController函数在registerReceiver中执行了一次，这里是否重复了？
        initFlightController();
        IntentFilter filter = new IntentFilter();
        filter.addAction(DemoApplication.FLAG_CONNECTION_CHANGE);
        registerReceiver(mReceiver, filter);

        // 为了防止空指针异常，将创建对象写在此处，是否会有问题？
        tarmacTracker = new MultiBoxTarmacTracker(this);

        resultList = (RecyclerView) findViewById(R.id.recognition_result_list);
        resultData();
        resultList.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false));
        adapter = new RecognitionResultAdapter(resultItemArrayList);
        resultList.setAdapter(adapter);
        resultList.setOnTouchListener(this);

    }

    /**
     * 初始化地图
     */
    private void initMapView() {
        LatLng softwarePark = new LatLng(36.667094, 117.140428); // 软件园校区经纬度
        cameraPosition = new CameraPosition.Builder().target(softwarePark).zoom(18).tilt(70).build();
        if (aMap == null) {
            aMap = mapView.getMap();
            uiSettings = aMap.getUiSettings();
            uiSettings.setZoomControlsEnabled(false);
            uiSettings.setZoomInByScreenCenter(true);
            uiSettings.setAllGesturesEnabled(true);
            uiSettings.setCompassEnabled(true);
            mapView.setClickable(true);
        }
        aMap.moveCamera(CameraUpdateFactory.newCameraPosition(cameraPosition));
        polylineOptions = new PolylineOptions().width(15).geodesic(true).color(Color.GREEN);
    }

    /**
     * Update the drone location based on states from MCU.
     * 更新无人机状态信息
     */
    private void updateDroneState() {

        if (droneGDLocationLat != 0 && droneGDLocationLng != 0) {
            final LatLng pos = new LatLng(droneGDLocationLat, droneGDLocationLng);
            //Create MarkerOptions object
            final MarkerOptions markerOptions = new MarkerOptions();
            markerOptions.position(pos);
            markerOptions.icon(BitmapDescriptorFactory.fromResource(R.drawable.aircraft));

            Log.i("dongupdateDroneState", "updateDroneState: getYaw: " + yaw + " getLatitude: " + pos.latitude + " getLongitude: " + pos.longitude + " Altitude: " + aircraftHeight + " GimbalPitch: " + gimbalPitch);

            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    if (droneMarker != null) {
                        droneMarker.remove();
                    }
                    if (checkGpsCoordination(droneGDLocationLat, droneGDLocationLng)) {
                        droneMarker = aMap.addMarker(markerOptions);
                    }
                }
            });
        }
    }

    public static boolean checkGpsCoordination(double latitude, double longitude) {
        return (latitude > -90 && latitude < 90 && longitude > -180 && longitude < 180) && (latitude != 0f && longitude != 0f);
    }

    /**
     * 移动地图到指定位置区域
     */
    private void cameraUpdate() {
        if (droneGDLocationLat != 0 && droneGDLocationLng != 0) {
            LatLng pos = new LatLng(droneGDLocationLat, droneGDLocationLng);
            float zoomlevel = (float) 18.0;
        }
    }

    // 监听与无人机连接状态的广播
    protected BroadcastReceiver mReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            onProductConnectionChange();
        }
    };

    private void onProductConnectionChange() {
        initFlightController();
        initSurfaceOrTextureView();
        //        cameraUpdate();
    }

    /**
     * 初始化无人机控制，并获取无人机位置、各种状态
     */
    private void initFlightController() {
        BaseProduct product = DemoApplication.getProductInstance();
        if (product == null || !product.isConnected()) {
            setResultToToast("未连接到无人机！");
            missionControl = null;
        } else {
            missionControl = MissionControl.getInstance(); // 任务控制器实例
            if (product instanceof Aircraft) {
                //                mFlightController = ((Aircraft) product).getFlightController();
                Aircraft aircraft = (Aircraft) DJISDKManager.getInstance().getProduct();
                mFlightController = aircraft.getFlightController();
                gimbal = product.getGimbal();
                battery = product.getBattery();
                camera = product.getCamera();
            }
        }
        // 云台
        if (gimbal != null) {
            gimbal.setStateCallback(new GimbalState.Callback() {
                @Override
                public void onUpdate(@NonNull final GimbalState gimbalState) {
                    new Handler(Looper.getMainLooper()).post(new Runnable() {
                        @Override
                        public void run() {
                            gimbalYaw = gimbalState.getAttitudeInDegrees().getYaw();
                            gimbalPitch = gimbalState.getAttitudeInDegrees().getPitch();
                            runOnUiThread(new Runnable() {
                                @Override
                                public void run() {
                                    pitchTv.setText("gimbalPitch: " + gimbalPitch + "°");
                                }
                            });
                        }
                    });
                }
            });
        }
        // 相机
        if (camera != null) {
            camera.setSystemStateCallback(new SystemState.Callback() {
                @Override
                public void onUpdate(@NonNull SystemState systemState) {
                    if (systemState.isShootingSinglePhoto() && !isShot) {
                        imageCount++;
                        Log.i("Timeline", "imageCount:" + imageCount);
                        isShot = true;
                    } else if (!systemState.isShootingSinglePhoto() && isShot) {
                        Log.i("Timeline", "Shooting Single Photo is End.imageCount:" + imageCount);
                        isShot = false;
                    }
                    if (systemState.isRecording() && !isRecord) {
                        videoStartTime = System.currentTimeMillis();
                        Log.i("Timeline", "videoTimeStart:" + videoStartTime);
                        isRecord = true;
                    } else if (!systemState.isRecording() && isRecord) {
                        videoEndTime = System.currentTimeMillis();
                        videoLength += (int) (videoEndTime - videoStartTime);
                        Log.i("Timeline", "videoTimeEnd:" + videoEndTime);
                        Log.i("Timeline", "videoLength:" + videoLength);
                        isRecord = false;
                    }
                }
            });

            camera.getLensInformation(new CommonCallbacks.CompletionCallbackWith<String>() {
                @Override
                public void onSuccess(String s) {
                    Log.i("donggetLensInformation", "onSuccess: " + s);
                }

                @Override
                public void onFailure(DJIError djiError) {
                    Log.i("donggetLensInformation", "onFailure: ");
                }
            });
        }
        // 电池
        if (battery != null) {
            battery.setStateCallback(new BatteryState.Callback() {
                @Override
                public void onUpdate(BatteryState batteryState) {
                    batteryRemianing = batteryState.getChargeRemaining();
                }
            });
        }

        // 无人机
        if (mFlightController != null) {
            mFlightController.setRollPitchControlMode(RollPitchControlMode.VELOCITY);
            mFlightController.setYawControlMode(YawControlMode.ANGULAR_VELOCITY);
            //            mFlightController.setYawControlMode(YawControlMode.ANGLE);
            mFlightController.setVerticalControlMode(VerticalControlMode.VELOCITY);
            mFlightController.setRollPitchCoordinateSystem(FlightCoordinateSystem.BODY);
            mFlightController.getSimulator().setStateCallback(new SimulatorState.Callback() {
                @Override
                public void onUpdate(final SimulatorState stateData) {
                    new Handler(Looper.getMainLooper()).post(new Runnable() {
                        @Override
                        public void run() {

                            String yaw = String.format("%.2f", stateData.getYaw());
                            String pitch = String.format("%.2f", stateData.getPitch());
                            String roll = String.format("%.2f", stateData.getRoll());
                            String positionX = String.format("%.2f", stateData.getPositionX());
                            String positionY = String.format("%.2f", stateData.getPositionY());
                            String positionZ = String.format("%.2f", stateData.getPositionZ());
                            Log.i("Timeline", "simulator yaw:" + yaw + " |pitch:" + pitch + " |roll" + roll + " |positionX:" + positionX + " |positionY" + positionY + " |positionZ:" + positionZ);
                        }
                    });
                }
            });
            mFlightController.setStateCallback(new FlightControllerState.Callback() {
                @Override
                public void onUpdate(FlightControllerState djiFlightControllerCurrentState) {
                    sourceLatLng = new LatLng(djiFlightControllerCurrentState.getAircraftLocation().getLatitude(), djiFlightControllerCurrentState.getAircraftLocation().getLongitude());
                    aircraftHeight = djiFlightControllerCurrentState.getAircraftLocation().getAltitude();
                    ultrasonicHeight = djiFlightControllerCurrentState.getUltrasonicHeightInMeters();
                    runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            ultrasonicTv.setText(ultrasonicHeight + " m");
                        }
                    });
                    if (maxAltitude < aircraftHeight) {
                        maxAltitude = aircraftHeight;
                    }
                    Log.i("aircraftHeight", "aircraftHeight:" + aircraftHeight);
                    flightMode = djiFlightControllerCurrentState.getFlightMode();
                    roll = djiFlightControllerCurrentState.getAttitude().roll;
                    yaw = djiFlightControllerCurrentState.getAttitude().yaw;
                    runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            yawTv.setText("yaw: " + yaw + "°");
                        }
                    });
                    pitch = djiFlightControllerCurrentState.getAttitude().pitch;
                    satelliteCount = djiFlightControllerCurrentState.getSatelliteCount();
                    velocityX = djiFlightControllerCurrentState.getVelocityX();
                    velocityY = djiFlightControllerCurrentState.getVelocityY();
                    velocityZ = djiFlightControllerCurrentState.getVelocityZ();
                    flightTime = djiFlightControllerCurrentState.getFlightTimeInSeconds();

                    Log.i("dongyaw", "yaw: " + yaw);

                    CoordinateConverter converter = new CoordinateConverter(getApplicationContext());
                    converter.from(CoordinateConverter.CoordType.GPS);
                    // sourceLatLng 待转换坐标点 LatLng类型
                    converter.coord(sourceLatLng);
                    // 执行转换操作，转换为高德坐标
                    LatLng desLatLng = converter.convert();
                    droneGDLocationLat = desLatLng.latitude;
                    droneGDLocationLng = desLatLng.longitude;
                    //                    Log.i("dongupdateDroneState", "onUpdate: droneGDLocationLat: " + droneGDLocationLat + " droneGDLocationLat: " + droneGDLocationLat);
                    Log.i("dongupdateDroneState", "onUpdate: droneGDLocationLat: " + sourceLatLng.latitude + " droneGDLocationLat: " + sourceLatLng.longitude);
                    if (!isGetHome) { // 获取home点坐标
                        homeLatitude = sourceLatLng.latitude;
                        homeLongitude = sourceLatLng.longitude;
                        homeGDLatitude = desLatLng.latitude;
                        homeGDLongitude = desLatLng.longitude;
                        isGetHome = true;
                    }
                    // droneLocationHeight = djiFlightControllerCurrentState.getAircraftLocation().getAltitude();
                    updateDroneState();
                    cameraUpdate();
                }
            });
        }
    }

    @Override
    public boolean onTouch(View v, MotionEvent motionEvent) {
        switch (v.getId()) {
            case R.id.detect_button:
                if (motionEvent.getAction() == MotionEvent.ACTION_DOWN) {
                    detectIv.setImageResource(R.mipmap.detect_close_p);
                }
                if (motionEvent.getAction() == MotionEvent.ACTION_UP) {

                    // 如果没有开始识别，打开选择识别模式的对话框
                    if (!isDetection) {
                        final AlertDialog alertDialog = new AlertDialog.Builder(this).create();
                        alertDialog.show();

                        Window window = alertDialog.getWindow();
                        //实现提示窗体透明的代码
                        WindowManager.LayoutParams attributes = window.getAttributes();
                        attributes.alpha = 0.6f;
                        window.setAttributes(attributes);
                        window.setContentView(R.layout.detection_dialog);

                        Button btn_detection = window.findViewById(R.id.btn_detection);
                        Button btn_cancel = window.findViewById(R.id.btn_cancel);

                        btn_detection.setOnClickListener(new View.OnClickListener() {
                            @Override
                            public void onClick(View view) {
//                                Toast.makeText(MainActivity.this, "确定", Toast.LENGTH_SHORT).show();
                                pidControlIncTestX.initPID(0.0001f, 0.000001f, 0.000001f);
                                pidControlIncTestY.initPID(0.0001f, 0.000001f, 0.000001f);

                                if (mFlightController != null) {
                                    mFlightController.setVirtualStickModeEnabled(true, new CommonCallbacks.CompletionCallback() {
                                        @Override
                                        public void onResult(DJIError djiError) {
                                            if (djiError != null) {
                                                setResultToToast(djiError.getDescription());
                                            } else {
                                                isSimulator = true;
                                                runOnUiThread(new Runnable() {
                                                    @Override
                                                    public void run() {
                                                        disableSimulatorIv.setImageResource(R.mipmap.aircraft_mode);
                                                        //                                                                    setResultToToast("虚拟摇杆开启");
                                                    }
                                                });
                                            }
                                        }
                                    });
                                }

                                if (!tagFlag) {
                                    Log.i("dongtagFlag", "onClick: tagRunnable");
                                    tagFlag = true;
                                    isDetection = true;
                                    tagThread = new Thread(tagRunnable);
                                    tagThread.start();
                                    detectIv.setImageResource(R.mipmap.detect_open);
                                    recognizerForAprilTags = new ApriltagsDetectAPIModel();
                                }

                                // TODO 测试自动降落时，这里要打开
//                                if (isLandingOpen) {
//                                    if (ultrasonicHeight > 7.7) {
//                                        pidControlIncTestX.initPID(0.0009f, 0.00002f, 0.00001f);
//                                        pidControlIncTestY.initPID(0.0009f, 0.00002f, 0.00001f);
//                                    }
//                                    if (ultrasonicHeight <= 7.7 && ultrasonicHeight > 5.2) {
//                                        pidControlIncTestX.initPID(0.0008f, 0.00002f, 0.00001f);
//                                        pidControlIncTestY.initPID(0.0008f, 0.00002f, 0.00001f);
//                                    }
//                                    if (ultrasonicHeight <= 5.2 && ultrasonicHeight > 3.0) {
//                                        pidControlIncTestX.initPID(0.0003f, 0.00001f, 0.000009f);
//                                        pidControlIncTestY.initPID(0.0003f, 0.00001f, 0.000009f);
//                                    }
//                                    if (ultrasonicHeight <= 3.0) {
//
//                                        pidControlIncTestX.initPID(0.0001f, 0.000001f, 0.000001f);
//                                        pidControlIncTestY.initPID(0.0001f, 0.000001f, 0.000001f);
//                                    }
//                                    if (mFlightController != null) {
//                                        mFlightController.setVirtualStickModeEnabled(true, new CommonCallbacks.CompletionCallback() {
//                                            @Override
//                                            public void onResult(DJIError djiError) {
//                                                if (djiError != null) {
//                                                    setResultToToast(djiError.getDescription());
//                                                } else {
//                                                    isSimulator = true;
//                                                    runOnUiThread(new Runnable() {
//                                                        @Override
//                                                        public void run() {
//                                                            disableSimulatorIv.setImageResource(R.mipmap.aircraft_mode);
//                                                            //                                                                    setResultToToast("虚拟摇杆开启");
//                                                        }
//                                                    });
//                                                }
//                                            }
//                                        });
//                                    }
//                                }
//                                try {
//
//                                    ReadConfigFileUtil.initYolov2Tiny(getAssets().open("tarmac_20190327.param.bin"), getAssets().open("tarmac_20190327_140000.bin"), "yolov2Tiny");
//                                    ReadConfigFileUtil.readCacheLabelFromLocalFile(getAssets().open("words.txt"));
//
//                                } catch (IOException e) {
//                                    e.printStackTrace();
//                                }
//                                tarmacDetector = new TarmacDetectAPIModel("yolov2Tiny");
//
//                                isTarmacRec = true;
//                                detectIv.setImageResource(R.mipmap.detect_open);
//                                tarmacFlag = true;
//                                tarmacThread = new Thread(tarmacRunnable);
//                                tarmacThread.start();
////                                recognizerForAprilTags = new ApriltagsDetectAPIModel();
//                                isDetection = true;
//                                Toast.makeText(MainActivity.this, "识别停机坪", Toast.LENGTH_SHORT).show();
//                                if (!isTarmacTrackVisible) {
//                                    if (trackingOverlay != null) {
//                                        trackingOverlay.setVisibility(View.VISIBLE);
//                                        isTarmacTrackVisible = true;
//                                    }
//                                }
                                alertDialog.dismiss();
                            }
                        });
                    } else {
                        AlertDialog.Builder builder = new AlertDialog.Builder(this);
                        builder.setTitle("是否关闭识别功能？");
                        builder.setPositiveButton("确定", new DialogInterface.OnClickListener() {
                            @Override
                            public void onClick(DialogInterface dialog, int which) {
                                detectIv.setImageResource(R.mipmap.detect_close_u);

                                if (mFlightController != null) {
                                    mFlightController.setVirtualStickModeEnabled(false, new CommonCallbacks.CompletionCallback() {
                                        @Override
                                        public void onResult(DJIError djiError) {
                                            if (djiError != null) {
                                                setResultToToast(djiError.getDescription());
                                            } else {
                                                isSimulator = false;
                                                //                                        setResultToToast("虚拟摇杆关闭");
                                                runOnUiThread(new Runnable() {
                                                    @Override
                                                    public void run() {
                                                        disableSimulatorIv.setImageResource(R.mipmap.rc_mode);
                                                    }
                                                });
                                            }
                                        }
                                    });
                                }

                                if (tarmacThread != null && tarmacThread.isAlive()) {
                                    tarmacFlag = false;
                                    isDetection = false;
                                    trackingOverlay.setVisibility(View.INVISIBLE);
                                    tarmacThread.interrupt();
                                    tarmacDetector.close();
                                    Toast.makeText(MainActivity.this, "识别功能关闭", Toast.LENGTH_SHORT).show();
                                    isTarmacTrackVisible = false;
                                    isTarmacRec = false;
                                    isPoppyRec = false;
                                }
                                if (tagFlag) {
                                    tagFlag = false;
                                    isDetection = false;
                                    tagThread.interrupt();
                                }
                                dialog.dismiss();
                            }
                        });
                        builder.setNegativeButton("取消", new DialogInterface.OnClickListener() {
                            @Override
                            public void onClick(DialogInterface dialog, int which) {
                                dialog.dismiss();
                            }
                        });
                        builder.show();
                    }
                }
                break;
        }
        return true;
    }

    @Override
    public void onClick(View view) {
        switch (view.getId()) {

            case R.id.tracking_drawer_control_ib:

                if (mPushInfoSd.isOpened()) {
                    Log.i("tracking_drawer", "isOpened: animateClose");
                    mPushInfoSd.animateClose();
                } else {
                    Log.i("tracking_drawer", "isClosed: animateOpen");
                    mPushInfoSd.animateOpen();
                }


            case R.id.simulator_stop_iv:
                if (mFlightController != null) {
                    mFlightController.setVirtualStickModeEnabled(false, new CommonCallbacks.CompletionCallback() {
                        @Override
                        public void onResult(DJIError djiError) {
                            if (djiError != null) {
                                setResultToToast(djiError.getDescription());
                            } else {
                                isSimulator = false;
                                //                                        setResultToToast("虚拟摇杆关闭");
                                runOnUiThread(new Runnable() {
                                    @Override
                                    public void run() {
                                        disableSimulatorIv.setImageResource(R.mipmap.rc_mode);
                                    }
                                });
                            }
                        }
                    });
                }
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        initSurfaceOrTextureView();
        notifyStatusChange();
        initFlightController();

        double decimation = 4;
        double sigma = 0.0;
        int nthreads = 8;
        String tagFamily = "tag36h11";
//        double tagsize = 0.005184;
        double tagsize = 0.04;
        double fx = 5423.612353784232;
        double fy = 5519.056520316598;
        double cx = 1315.1967405060602;
        double cy = 838.5860437396254;
        ApriltagR.apriltagInit(tagFamily, 2, decimation, sigma, nthreads, tagsize, fx, fy, cx, cy);
        initFlightController();

        handlerThreadForTarmac = new HandlerThread("tarmac");
        handlerThreadForTarmac.start();
        handlerForTarmac = new Handler(handlerThreadForTarmac.getLooper());

        handlerThreadForAprilTags = new HandlerThread("AprilTags");
        handlerThreadForAprilTags.start();
        handlerForAprilTags = new Handler(handlerThreadForAprilTags.getLooper());

        mapView.onResume();

    }

    @Override
    protected void onPause() {
        if (mCamera != null) {
            if (VideoFeeder.getInstance().getPrimaryVideoFeed() != null) {
                VideoFeeder.getInstance().getPrimaryVideoFeed().removeVideoDataListener(mReceivedVideoDataListener);
            }
            if (standardVideoFeeder != null) {
                standardVideoFeeder.removeVideoDataListener(mReceivedVideoDataListener);
            }
        }
        super.onPause();
        mapView.onPause();
    }

    @Override
    protected void onDestroy() {
        if (mCodecManager != null) {
            mCodecManager.cleanSurface();
            mCodecManager.destroyCodec();
        }
        mapView.onDestroy();
        unregisterReceiver(mReceiver);
        tagFlag = false;
        if (tagThread != null) {
            if (tagThread.isAlive()) {
                tagThread.interrupt();
            }
        }
        isDetection = false;
        detectIv.setImageResource(R.mipmap.detect_close_u);
        // 关闭虚拟摇杆
        if (mFlightController != null) {
            mFlightController.setVirtualStickModeEnabled(false, new CommonCallbacks.CompletionCallback() {
                @Override
                public void onResult(DJIError djiError) {
                    if (djiError != null) {
                        setResultToToast(djiError.getDescription());
                    } else {
                        //                                                setResultToToast("虚拟摇杆关闭");
                    }
                }
            });
        }
        super.onDestroy();
    }

    private void initSurfaceOrTextureView() {
        switch (demoType) {

            case USE_SURFACE_VIEW_DEMO_DECODER:
                /**
                 * we also need init the textureView because the pre-transcoded video steam will display in the textureView
                 */
                initPreviewerTextureView();

                /**
                 * we use standardVideoFeeder to pass the transcoded video data to DJIVideoStreamDecoder, and then display it
                 * on surfaceView
                 */
                initPreviewerSurfaceView();
                break;

        }
    }

    private void notifyStatusChange() {

        final BaseProduct product = DemoApplication.getProductInstance();

        // The callback for receiving the raw H264 video data for camera live view
        mReceivedVideoDataListener = new VideoFeeder.VideoDataListener() {

            @Override
            public void onReceive(byte[] videoBuffer, int size) {

                switch (demoType) {

                    case USE_SURFACE_VIEW_DEMO_DECODER:
                        /**
                         we use standardVideoFeeder to pass the transcoded video data to DJIVideoStreamDecoder, and then display it
                         * on surfaceView
                         */
                        DJIVideoStreamDecoder.getInstance().parse(videoBuffer, size);
                        break;
                }
            }
        };

        if (null == product || !product.isConnected()) {
            mCamera = null;
            Toast.makeText(MainActivity.this, "Disconnected", Toast.LENGTH_LONG);
        } else {
            if (!product.getModel().equals(Model.UNKNOWN_AIRCRAFT)) {
                mCamera = product.getCamera();
                mCamera.setMode(SettingsDefinitions.CameraMode.SHOOT_PHOTO, new CommonCallbacks.CompletionCallback() {
                    @Override
                    public void onResult(DJIError djiError) {
                        if (djiError != null) {
                            Toast.makeText(MainActivity.this, "can't change mode of camera, error:" + djiError.getDescription(), Toast.LENGTH_LONG);
                        }
                    }
                });

                if (demoType == DemoType.USE_SURFACE_VIEW_DEMO_DECODER) {
                    if (VideoFeeder.getInstance() != null) {
                        standardVideoFeeder = VideoFeeder.getInstance().provideTranscodedVideoFeed();
                        standardVideoFeeder.addVideoDataListener(mReceivedVideoDataListener);
                    }
                } else {
                    if (VideoFeeder.getInstance().getPrimaryVideoFeed() != null) {
                        VideoFeeder.getInstance().getPrimaryVideoFeed().addVideoDataListener(mReceivedVideoDataListener);
                    }
                }
            }
        }
    }

    /**
     * Init a fake texture view to for the codec manager, so that the video raw data can be received
     * by the camera
     */
    private void initPreviewerTextureView() {
        fpvWidget.setSurfaceTextureListener(new TextureView.SurfaceTextureListener() {
            @Override
            public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) {
                Log.d(TAG, "real onSurfaceTextureAvailable");

                Log.d(TAG, "real onSurfaceTextureAvailable: width " + width + " height " + height);
                if (mCodecManager == null) {
                    mCodecManager = new DJICodecManager(getApplicationContext(), surface, width, height);
                }
            }

            @Override
            public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) {
                Log.d(TAG, "real onSurfaceTextureAvailable2: width " + width + " height " + height);
            }

            @Override
            public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) {
                if (mCodecManager != null) {
                    mCodecManager.cleanSurface();
                }
                return false;
            }

            @Override
            public void onSurfaceTextureUpdated(SurfaceTexture surface) {

            }
        });
    }

    /**
     * Init a surface view for the DJIVideoStreamDecoder
     */
    private void initPreviewerSurfaceView() {
        videostreamPreviewSh = videostreamPreviewSf.getHolder();
        surfaceCallback = new SurfaceHolder.Callback() {
            @Override
            public void surfaceCreated(SurfaceHolder holder) {
                Log.d(TAG, "real onSurfaceTextureAvailable");

                Log.d(TAG, "real onSurfaceTextureAvailable3: width " + videostreamPreviewSf.getWidth() + " height " + videostreamPreviewSf.getHeight());
                switch (demoType) {

                    case USE_SURFACE_VIEW_DEMO_DECODER:
                        // This demo might not work well on P3C and OSMO.
                        NativeHelper.getInstance().init();
                        DJIVideoStreamDecoder.getInstance().init(getApplicationContext(), holder.getSurface());
                        DJIVideoStreamDecoder.getInstance().resume();
                        break;
                }
            }

            @Override
            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {

                Log.d(TAG, "real onSurfaceTextureAvailable4: width " + width + " height " + height);
                switch (demoType) {

                    case USE_SURFACE_VIEW_DEMO_DECODER:
                        DJIVideoStreamDecoder.getInstance().changeSurface(holder.getSurface());
                        break;
                }
            }

            @Override
            public void surfaceDestroyed(SurfaceHolder holder) {
                switch (demoType) {

                    case USE_SURFACE_VIEW_DEMO_DECODER:
                        DJIVideoStreamDecoder.getInstance().stop();
                        NativeHelper.getInstance().release();
                        break;
                }
            }
        };

        videostreamPreviewSh.addCallback(surfaceCallback);
    }

    @Override
    public void onYuvDataReceived(final ByteBuffer yuvFrame, int dataSize, final int width, final int height) {
        //In this demo, we test the YUV data by saving it into JPG files.
        //DJILog.d(TAG, "onYuvDataReceived " + dataSize);
        if (count++ % 30 == 0 && yuvFrame != null) {
            final byte[] bytes = new byte[dataSize];
            yuvFrame.get(bytes);
            //DJILog.d(TAG, "onYuvDataReceived2 " + dataSize);
            AsyncTask.execute(new Runnable() {
                @Override
                public void run() {
                    saveYuvDataToJPEG(bytes, width, height);
                }
            });
        }
    }

    private void saveYuvDataToJPEG(byte[] yuvFrame, int width, int height) {
        if (yuvFrame.length < width * height) {
            //DJILog.d(TAG, "yuvFrame size is too small " + yuvFrame.length);
            return;
        }

        byte[] y = new byte[width * height];
        byte[] u = new byte[width * height / 4];
        byte[] v = new byte[width * height / 4];
        byte[] nu = new byte[width * height / 4]; //
        byte[] nv = new byte[width * height / 4];

        System.arraycopy(yuvFrame, 0, y, 0, y.length);
        for (int i = 0; i < u.length; i++) {
            v[i] = yuvFrame[y.length + 2 * i];
            u[i] = yuvFrame[y.length + 2 * i + 1];
        }
        int uvWidth = width / 2;
        int uvHeight = height / 2;
        for (int j = 0; j < uvWidth / 2; j++) {
            for (int i = 0; i < uvHeight / 2; i++) {
                byte uSample1 = u[i * uvWidth + j];
                byte uSample2 = u[i * uvWidth + j + uvWidth / 2];
                byte vSample1 = v[(i + uvHeight / 2) * uvWidth + j];
                byte vSample2 = v[(i + uvHeight / 2) * uvWidth + j + uvWidth / 2];
                nu[2 * (i * uvWidth + j)] = uSample1;
                nu[2 * (i * uvWidth + j) + 1] = uSample1;
                nu[2 * (i * uvWidth + j) + uvWidth] = uSample2;
                nu[2 * (i * uvWidth + j) + 1 + uvWidth] = uSample2;
                nv[2 * (i * uvWidth + j)] = vSample1;
                nv[2 * (i * uvWidth + j) + 1] = vSample1;
                nv[2 * (i * uvWidth + j) + uvWidth] = vSample2;
                nv[2 * (i * uvWidth + j) + 1 + uvWidth] = vSample2;
            }
        }
        //nv21test
        byte[] bytes = new byte[yuvFrame.length];
        System.arraycopy(y, 0, bytes, 0, y.length);
        for (int i = 0; i < u.length; i++) {
            bytes[y.length + (i * 2)] = nv[i];
            bytes[y.length + (i * 2) + 1] = nu[i];
        }
        Log.d(TAG, "onYuvDataReceived: frame index: " + DJIVideoStreamDecoder.getInstance().frameIndex + ",array length: " + bytes.length);
        screenShot(bytes, Environment.getExternalStorageDirectory() + "/DJI_ScreenShot", width, height);
    }

    /**
     * Save the buffered data into a JPG image file
     */
    private void screenShot(byte[] buf, String shotDir, int width, int height) {
        File dir = new File(shotDir);
        if (!dir.exists() || !dir.isDirectory()) {
            dir.mkdirs();
        }
        YuvImage yuvImage = new YuvImage(buf, ImageFormat.NV21, width, height, null);
        OutputStream outputFile;
        final String path = dir + "/ScreenShot_" + System.currentTimeMillis() + ".jpg";
        try {
            outputFile = new FileOutputStream(new File(path));
        } catch (FileNotFoundException e) {
            Log.e(TAG, "test screenShot: new bitmap output file error: " + e);
            return;
        }
        if (outputFile != null) {
            yuvImage.compressToJpeg(new Rect(0, 0, width, height), 100, outputFile);
        }
        try {
            outputFile.close();
        } catch (IOException e) {
            Log.e(TAG, "test screenShot: compress yuv image error: " + e);
            e.printStackTrace();
        }

    }

    private void loginAccount() {
        UserAccountManager.getInstance().logIntoDJIUserAccount(this, new CommonCallbacks.CompletionCallbackWith<UserAccountState>() {
            @Override
            public void onSuccess(final UserAccountState userAccountState) {
                Toast.makeText(MainActivity.this, "Login Success", Toast.LENGTH_LONG);
            }

            @Override
            public void onFailure(DJIError error) {
                Toast.makeText(MainActivity.this, "Login Error:" + error.getDescription(), Toast.LENGTH_LONG);
            }
        });

    }

    private void setResultToToast(final String string) {
        MainActivity.this.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Toast.makeText(MainActivity.this, string, Toast.LENGTH_SHORT).show();
            }
        });
    }

    private String getTime(long timeStamp) {
        String time = "";
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
        time = sdf.format(new Date(timeStamp)).split(" ")[1];// 单位s
        return time;
    }


    /**
     * 亮度 跨度
     * @return
     */
    protected int getLuminanceStride() {
        return yRowStride;
    }

    /**
     * 获取屏幕旋转角度（返回数值为顺时针旋转角度，手机数值放置为0度）
     *
     * @return
     */
    protected int getScreenOrientation() {
        switch (getWindowManager().getDefaultDisplay().getRotation()) {
            case Surface.ROTATION_270:
                return 270;
            case Surface.ROTATION_180:
                return 180;
            case Surface.ROTATION_90:
                return 90;
            default:
                return 0;
        }
    }

    /**
     * 学习一下Handler和HandlerThread
     * @param r
     */
    protected synchronized void runInBackgroundForTarmac(final Runnable r) {
        if (handlerForTarmac != null) {
            handlerForTarmac.post(r);
        }
    }

    protected synchronized void runInBackgroundForAprilTags(final Runnable r) {
        if (handlerForAprilTags != null) {
            handlerForAprilTags.post(r);
        }
    }

    /**
     * Push AprilTags Status to TextView
     *
     * @param string
     */
    private void setResultToText(final String string, int id) {
        //        if (mPushInfoTv == null) {
        //            setResultToToast("Push info tv has not be init...");
        //        }
        if (id == 1) {
            MainActivity.this.runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    ltPushInfoTv.setText(string);
                }
            });
        }
        if (id == 2) {
            MainActivity.this.runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    rtPushInfoTv.setText(string);
                }
            });
        }
        if (id == 25) {
            MainActivity.this.runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    lbPushInfoTv.setText(string);
                }
            });
        }
        if (id == 3) {
            MainActivity.this.runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    rbPushInfoTv.setText(string);
                }
            });
        }
        if (id == 0) {
            MainActivity.this.runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    cPushInfoTv.setText(string);
                }
            });
        }
    }

    /**
     * 显示在左下角的识别结果列表数据
     */
    private void resultData() {
        resultItemArrayList = new ArrayList<>();
        RecognitionResultItem recognitionResultItem1 = new RecognitionResultItem("等待识别...", "", "", "", "", "", "", "", "");
        resultItemArrayList.add(recognitionResultItem1);
        for (int i = 0; i < 4; i++) {
            RecognitionResultItem recognitionResultItem = new RecognitionResultItem("", "", "", "", "", "", "", "", "");
            resultItemArrayList.add(recognitionResultItem);
        }
    }

}
